# @ cmucl
# SOME DESCRIPTIVE TITLE
# Copyright (C) 2010
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: CMUCL 20b\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI +ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: target:code/intl.lisp
msgid ""
"The message-lookup domain used by INTL:GETTEXT and INTL:NGETTEXT.\n"
"  Use (INTL:TEXTDOMAIN \"whatever\") in each source file to set this."
msgstr ""

#: target:code/intl.lisp
msgid "Encountered illegal token: ="
msgstr ""

#: target:code/intl.lisp
msgid "Encountered illegal token: ~C"
msgstr ""

#: target:code/intl.lisp
msgid "Expected : in ?: construct"
msgstr ""

#: target:code/intl.lisp
msgid "Expected close-paren."
msgstr ""

#: target:code/intl.lisp
msgid "Unexpected token: ~S."
msgstr ""

#: target:code/intl.lisp
msgid "Expecting end of expression.  ~S."
msgstr ""

#: target:code/intl.lisp
msgid "Bad magic number in \"~A.mo\"."
msgstr ""

#: target:code/intl.lisp
msgid ""
"Look up STRING in the current message domain and return its translation."
msgstr ""

#: target:code/intl.lisp
msgid "Look up the singular or plural form of a message in the current domain."
msgstr ""

#: target:code/intl.lisp
msgid ""
"Look up STRING in the specified message domain and return its translation."
msgstr ""

#: target:code/intl.lisp
msgid ""
"Look up the singular or plural form of a message in the specified domain."
msgstr ""

#: target:code/intl.lisp
msgid "_@ is a reserved reader macro prefix."
msgstr ""

#: target:code/fwrappers.lisp
msgid ""
"A funcallable instance used to implement fwrappers.\n"
"   The CONSTRUCTOR slot is a function defined with DEFINE-FWRAPPER.\n"
"   This function returns an instance closure closing over an \n"
"   fwrapper object, which is installed as the funcallable-instance\n"
"   function of the fwrapper object."
msgstr ""

#: target:code/fwrappers.lisp
msgid "Print-function for struct FWRAPPER."
msgstr ""

#: target:code/fwrappers.lisp
msgid "Return FUN if it is an fwrapper or nil if it isn't."
msgstr ""

#: target:code/fwrappers.lisp
msgid ""
"Evaluate BODY with VAR bound to consecutive fwrappers of\n"
"   FDEFN.  Return RESULT at the end."
msgstr ""

#: target:code/fwrappers.lisp
msgid "Return tha last encapsulation of FDEFN or NIL if none."
msgstr ""

#: target:code/fwrappers.lisp
msgid ""
"Prepend encapsulation F to the definition of FUNCTION-NAME.\n"
"   Signal an error if FUNCTION-NAME is an undefined function."
msgstr ""

#: target:code/fwrappers.lisp
msgid "Remove fwrapper F from the definition of FUNCTION-NAME."
msgstr ""

#: target:code/fwrappers.lisp
msgid ""
"Return a list of all fwrappers of FUNCTION-NAME, ordered\n"
"   from outermost to innermost."
msgstr ""

#: target:code/fwrappers.lisp
msgid ""
"Set FUNCTION-NAMES's fwrappers to elements of the list\n"
"   FWRAPPERS, which is assumed to be ordered from outermost to\n"
"   innermost.  FWRAPPERS null means remove all fwrappers."
msgstr ""

#: target:code/fwrappers.lisp
msgid ""
"Wrap the function named FUNCTION-NAME in an fwrapper of type TYPE,\n"
"   created by calling CONSTRUCTOR.  CONSTRUCTOR is a function\n"
"   defined with DEFINE-FWRAPPER, or the name of such a function.\n"
"   Return the fwrapper created.  USER-DATA is arbitrary data to be\n"
"   associated with the fwrapper.  It is accessible in wrapper\n"
"   functions defined with DEFINE-FWRAPPER as (FWRAPPER-USER-DATA\n"
"   FWRAPPER)."
msgstr ""

#: target:code/fwrappers.lisp
msgid ""
"Remove fwrappers from the function named FUNCTION-NAME.\n"
"   If TYPE is supplied, remove fwrappers whose type is equal to TYPE.\n"
"   If TEST is supplied, remove fwrappers satisfying TEST.\n"
"   If both are not specified, remove all fwrappers."
msgstr ""

#: target:code/fwrappers.lisp
msgid ""
"Update the funcallable instance function of fwrapper F from its\n"
"   constructor."
msgstr ""

#: target:code/fwrappers.lisp
msgid ""
"Update fwrapper function definitions of FUNCTION-NAME.\n"
"   If TYPE is supplied, update fwrappers whose type is equal to TYPE.\n"
"   If TEST is supplied, update fwrappers satisfying TEST."
msgstr ""

#: target:code/fwrappers.lisp
msgid ""
"Find an fwrapper of FUNCTION-NAME.\n"
"   If TYPE is supplied, find an fwrapper whose type is equal to TYPE.\n"
"   If TEST is supplied, find an fwrapper satisfying TEST."
msgstr ""

#: target:code/fwrappers.lisp
msgid ""
"Like DEFUN, but define a function wrapper.\n"
"   In BODY, the symbol FWRAPPERS:FWRAPPERS refers to the currently\n"
"   executing fwrapper.  FWRAPPERS:CALL-NEXT-FUNCTION can be used\n"
"   in BODY to call the next fwrapper or the primary function.  When\n"
"   called with no arguments, CALL-NEXT-FUNCTION invokes the next\n"
"   function with the original args to the fwrapper, otherwise it\n"
"   invokes the next function with the supplied args."
msgstr ""

#: target:code/fwrappers.lisp
msgid "Return the expansion of a DEFINE-FWRAPPER."
msgstr ""

#: target:code/fwrappers.lisp
msgid ""
"First value is true if BODY refers to any of the variables in\n"
"     OPTIONALS, KEYS or REST, which are what KERNEL:PARSE-LAMBDA-LIST\n"
"     returns.  Second value is true if BODY refers to REST."
msgstr ""

#: target:code/fwrappers.lisp
msgid "&MORE not supported in fwrapper lambda lists"
msgstr ""

#: target:code/fwrappers.lisp
msgid "Fwrapper for old-style encapsulations."
msgstr ""

#: target:code/fwrappers.lisp
msgid "This function is deprecated; use fwrappers instead."
msgstr ""

#: target:code/fdefinition.lisp
msgid ""
"Define (NAME ...) to be a valid function name whose syntax is checked\n"
"  by BODY.  In BODY, VAR is bound to an actual function name of the\n"
"  form (NAME ...) to check.  BODY should return two values.\n"
"  First value true means the function name is valid.  Second value\n"
"  is the name, a symbol, of the function for use in the BLOCK of DEFUNs\n"
"  and in similar situations."
msgstr ""

#: target:code/fdefinition.lisp
msgid ""
"First value is true if NAME has valid function name syntax.\n"
"  Second value is the name, a symbol, to use as a block name in DEFUNs\n"
"  and in similar situations."
msgstr ""

#: target:code/fdefinition.lisp
msgid ""
"Return the fdefn object for NAME.  If it doesn't already exist and CREATE\n"
"   is non-NIL, create a new (unbound) one."
msgstr ""

#: target:code/fdefinition.lisp
msgid "Invalid function name: ~S"
msgstr ""

#: target:code/fdefinition.lisp
msgid ""
"Return the FDEFN of NAME.  Signal an error if there is none\n"
"   or if it's function is null."
msgstr ""

#: target:code/fdefinition.lisp
msgid ""
"Returns the definition for name, including any encapsulations.  Settable\n"
"   with SETF."
msgstr ""

#: target:code/fdefinition.lisp
msgid ""
"Return FUNCTION-NAME's global function definition.\n"
"   If FUNCTION-NAME is fwrapped, return the primary function definition\n"
"   stored in the innermost fwrapper."
msgstr ""

#: target:code/fdefinition.lisp
msgid ""
"This holds functions that (SETF FDEFINITION) invokes before storing the\n"
"   new value.  These functions take the function name and the new value."
msgstr ""

#: target:code/fdefinition.lisp
msgid ""
"Set FUNCTION-NAME's global function definition to NEW-VALUE.\n"
"   If FUNCTION-NAME is fwrapped, set the primary function stored\n"
"   in the innermost fwrapper."
msgstr ""

#: target:code/fdefinition.lisp
msgid "Return true if name has a global function definition."
msgstr ""

#: target:code/fdefinition.lisp
msgid "Make Name have no global function definition."
msgstr ""

#: target:code/error.lisp
msgid "&rest keyword is ~:[missing~;misplaced~]."
msgstr ""

#: target:code/error.lisp
msgid ""
"Return a list of all the currently active restarts ordered from most\n"
"   recently established to less recently established.  If Condition is\n"
"   specified, then only restarts associated with Condition (or with no\n"
"   condition) will be returned."
msgstr ""

#: target:code/error.lisp
msgid "Returns the name of the given restart object."
msgstr ""

#: target:code/error.lisp
msgid ""
"WITH-CONDITION-RESTARTS Condition-Form Restarts-Form Form*\n"
"   Evaluates the Forms in a dynamic environment where the restarts in the "
"list\n"
"   Restarts-Form are associated with the condition returned by Condition-"
"Form.\n"
"   This allows FIND-RESTART, etc., to recognize restarts that are not "
"related\n"
"   to the error currently being debugged.  See also RESTART-CASE."
msgstr ""

#: target:code/error.lisp
msgid ""
"Executes forms in a dynamic context where the given restart bindings are\n"
"   in effect.  Users probably want to use RESTART-CASE.  When clauses "
"contain\n"
"   the same restart name, FIND-RESTART will find the first such clause."
msgstr ""

#: target:code/error.lisp
msgid ""
"Unnamed restart does not have a ~\n"
"\t\t\t\t\treport function -- ~S"
msgstr ""

#: target:code/error.lisp
msgid ""
"Returns the first restart named name.  If name is a restart, it is returned\n"
"   if it is currently active.  If no such restart is found, nil is "
"returned.\n"
"   It is an error to supply nil as a name.  If Condition is specified and "
"not\n"
"   NIL, then only restarts associated with that condition (or with no\n"
"   condition) will be returned."
msgstr ""

#: target:code/error.lisp
msgid ""
"Calls the function associated with the given restart, passing any given\n"
"   arguments.  If the argument restart is not a restart or a currently "
"active\n"
"   non-nil restart name, then a control-error is signalled."
msgstr ""

#: target:code/error.lisp
msgid "Restart ~S is not active."
msgstr ""

#: target:code/error.lisp
msgid ""
"Calls the function associated with the given restart, prompting for any\n"
"   necessary arguments.  If the argument restart is not a restart or a\n"
"   currently active non-nil restart name, then a control-error is signalled."
msgstr ""

#: target:code/error.lisp
msgid ""
"(RESTART-CASE form\n"
"   {(case-name arg-list {keyword value}* body)}*)\n"
"   The form is evaluated in a dynamic context where the clauses have "
"special\n"
"   meanings as points to which control may be transferred (see INVOKE-"
"RESTART).\n"
"   When clauses contain the same case-name, FIND-RESTART will find the "
"first\n"
"   such clause.  If Expression is a call to SIGNAL, ERROR, CERROR or WARN "
"(or\n"
"   macroexpands into such) then the signalled condition will be associated "
"with\n"
"   the new restarts."
msgstr ""

#: target:code/error.lisp
msgid ""
"(WITH-SIMPLE-RESTART (restart-name format-string format-arguments)\n"
"   body)\n"
"   If restart-name is not invoked, then all values returned by forms are\n"
"   returned.  If control is transferred to this restart, it immediately\n"
"   returns the values nil and t."
msgstr ""

#: target:code/error.lisp
msgid "Condition ~S was signalled."
msgstr ""

#: target:code/error.lisp
msgid "No REPORT?  Shouldn't happen!"
msgstr ""

#: target:code/error.lisp
msgid "Condition slot is not bound: ~S"
msgstr ""

#: target:code/error.lisp
msgid "Slot ~S of ~S missing."
msgstr ""

#: target:code/error.lisp
msgid "Make an instance of a condition object using the specified initargs."
msgstr ""

#: target:code/error.lisp
msgid "~S is not a condition class."
msgstr ""

#: target:code/error.lisp
msgid "Bad thing for class arg:~%  ~S"
msgstr ""

#: target:code/error.lisp
msgid "Condition already names a declaration: ~S."
msgstr ""

#: target:code/error.lisp
msgid ""
"DEFINE-CONDITION Name (Parent-Type*) (Slot-Spec*) Option*\n"
"   Define NAME as a condition type.  This new type inherits slots and its\n"
"   report function from the specified PARENT-TYPEs.  A slot spec is either\n"
"   a symbol denoting the name of the slot, or a list of the form:\n"
"\n"
"     (slot-name {slot-option value}*)\n"
"\n"
"   where slot-option is one of :READER, :WRITER, :ACCESSOR, :ALLOCATION,\n"
"   :INITARG, :INITFORM, :DOCUMENTATION, and :TYPE.\n"
"\n"
"   Each overall option is of the form\n"
"\n"
"     (option-name {value}*)\n"
"\n"
"   where option-name is one of :DEFAULT-INITARGS, :DOCUMENTATION,\n"
"   and :REPORT.\n"
"\n"
"   The :REPORT option is peculiar to DEFINE-CONDITION.  Its argument is "
"either\n"
"   a string or a two-argument lambda or function name.  If a function, the\n"
"   function is called with the condition and stream to report the "
"condition.\n"
"   If a string, the string is printed.\n"
"\n"
"   Condition types are classes, but (as allowed by ANSI and not as described "
"in\n"
"   CLtL2) are neither STANDARD-OBJECTs nor STRUCTURE-OBJECTs.  WITH-SLOTS "
"and\n"
"   SLOT-VALUE may not be used on condition objects."
msgstr ""

#: target:code/error.lisp
msgid "Keyword slot name indicates probable syntax error:~%  ~S"
msgstr ""

#: target:code/error.lisp
msgid "Malformed condition slot spec:~%  ~S."
msgstr ""

#: target:code/error.lisp
msgid "More than one :INITFORM in:~%  ~S"
msgstr ""

#: target:code/error.lisp
msgid "More than one slot :DOCUMENTATION in~%  ~s"
msgstr ""

#: target:code/error.lisp
msgid "Slot :DOCUMENTATION is not a string in~%  ~s"
msgstr ""

#: target:code/error.lisp
msgid "Unknown slot option:~%  ~S"
msgstr ""

#: target:code/error.lisp
msgid "Bad option:~%  ~S"
msgstr ""

#: target:code/error.lisp
msgid "Unknown option: ~S"
msgstr ""

#: target:code/error.lisp
msgid ""
"(HANDLER-BIND ( {(type handler)}* )  body)\n"
"   Executes body in a dynamic context where the given handler bindings are\n"
"   in effect.  Each handler must take the condition being signalled as an\n"
"   argument.  The bindings are searched first to last in the event of a\n"
"   signalled condition."
msgstr ""

#: target:code/error.lisp
msgid "Ill-formed handler bindings."
msgstr ""

#: target:code/error.lisp
msgid "~&~@<Error in function ~S:  ~3i~:_~?~:>"
msgstr ""

#: target:code/error.lisp
msgid "Control stack overflow"
msgstr ""

#: target:code/error.lisp
msgid "Heap (dynamic space) overflow"
msgstr ""

#: target:code/error.lisp
msgid "~@<Type-error in ~S:  ~3i~:_~S is not of type ~S~:>"
msgstr ""

#: target:code/error.lisp
msgid ""
"Layout-invalid error in ~S:~@\n"
"\t\t     Type test of class ~S was passed obsolete instance:~%  ~S"
msgstr ""

#: target:code/error.lisp
msgid "~@<~S fell through ~S expression.  ~:_Wanted one of ~:S.~:>"
msgstr ""

#: target:code/error.lisp
msgid "End-of-File on ~S"
msgstr ""

#: target:code/error.lisp
msgid "~&~@<File-error in function ~S:  ~3i~:_~?~:>"
msgstr ""

#: target:code/error.lisp
msgid "Error in ~S:  the variable ~S is unbound."
msgstr ""

#: target:code/error.lisp
msgid "Error in ~S:  the function ~S is undefined."
msgstr ""

#: target:code/error.lisp
msgid ""
"~@<Destructive function ~S called on ~\n"
"                         constant data.~@:>"
msgstr ""

#: target:code/error.lisp
msgid "Arithmetic error ~S signalled."
msgstr ""

#: target:code/error.lisp
msgid "~%Operation was ~S, operands ~S."
msgstr ""

#: target:code/error.lisp
msgid ""
"(HANDLER-CASE form\n"
"   { (type ([var]) body) }* )\n"
"   Executes form in a context with handlers established for the condition\n"
"   types.  A peculiar property allows type to be :no-error.  If such a "
"clause\n"
"   occurs, and form returns normally, all its values are passed to this "
"clause\n"
"   as if by MULTIPLE-VALUE-CALL.  The :no-error clause accepts more than "
"one\n"
"   var specification."
msgstr ""

#: target:code/error.lisp
msgid ""
"Executes forms after establishing a handler for all error conditions that\n"
"   returns from this form nil and the condition signalled."
msgstr ""

#: target:code/error.lisp
msgid ""
"Transfers control to a restart named abort, signalling a control-error if\n"
"   none exists."
msgstr ""

#: target:code/error.lisp
msgid ""
"Transfers control to a restart named muffle-warning, signalling a\n"
"   control-error if none exists."
msgstr ""

#: target:code/error.lisp
msgid ""
"Transfer control to a restart named continue, returning nil if none exists."
msgstr ""

#: target:code/error.lisp
msgid ""
"Transfer control and value to a restart named store-value, returning nil if\n"
"   none exists."
msgstr ""

#: target:code/error.lisp
msgid ""
"Transfer control and value to a restart named use-value, returning nil if\n"
"   none exists."
msgstr ""

#: target:code/class.lisp
msgid "Layout for ~S~@[, Invalid=~S~]"
msgstr ""

#: target:code/class.lisp
msgid "The inclusive upper bound on LAYOUT-HASH values."
msgstr ""

#: target:code/class.lisp
msgid ""
"Layout depth conflict: ~S~%  ~\n"
"\t\t        (~S collides at ~S with ~S)~%"
msgstr ""

#: target:code/class.lisp
msgid "Can't use anonymous or undefined class as constant:~%  ~S"
msgstr ""

#: target:code/class.lisp
msgid "~:[<anonymous>~;~:*~S~]~@[ (~(~A~))~]"
msgstr ""

#: target:code/class.lisp
msgid ""
"Return the class with the specified Name.  If ERRORP is false, then NIL is\n"
"   returned when no such class exists."
msgstr ""

#: target:code/class.lisp
msgid "Class not yet defined:~%  ~S"
msgstr ""

#: target:code/class.lisp
msgid "Illegal to redefine standard type ~S."
msgstr ""

#: target:code/class.lisp
msgid "Changing meta-class of ~S from ~S to ~S."
msgstr ""

#: target:code/class.lisp
msgid "Redefining DEFTYPE type to be a class: ~S."
msgstr ""

#: target:code/class.lisp
msgid ""
"Return the class of the supplied object, which may be any Lisp object, not\n"
"   just a CLOS STANDARD-OBJECT."
msgstr ""

#: target:code/class.lisp
msgid "Modifing ~(~A~) class ~S; making it writable."
msgstr ""

#: target:code/class.lisp
msgid "Subclassing sealed class ~S; unsealing it."
msgstr ""

#: target:code/class.lisp
msgid ""
"Change in the inheritance structure of class ~S~%  ~\n"
"\t\t between the ~A definition and the ~A definition."
msgstr ""

#: target:code/class.lisp
msgid ""
"Change in instance length of class ~S:~%  ~\n"
"\t\t   ~A length: ~D~%  ~\n"
"\t\t   ~A length: ~D"
msgstr ""

#: target:code/class.lisp
msgid ""
"In class ~S:~%  ~\n"
"\t\t    ~:(~A~) definition of superclass ~S incompatible with~%  ~\n"
"\t\t    ~A definition."
msgstr ""

#: target:code/class.lisp
msgid ""
"Change in superclasses of class ~S:~%  ~\n"
"\t\t  ~A superclasses: ~S~%  ~\n"
"\t\t  ~A superclasses: ~S"
msgstr ""

#: target:code/class.lisp
msgid ""
"Loading a reference to class ~S when the compile~\n"
"\t\t       ~%  time definition was incompatible with the current ~\n"
"\t\t       one."
msgstr ""

#: target:code/class.lisp
msgid "New definition of ~S must be loaded eventually."
msgstr ""

#: target:code/class.lisp
msgid ""
"Any old ~S instances will be in a bad way.~@\n"
"\t\t      I hope you know what you're doing..."
msgstr ""

#: target:code/class.lisp
msgid ""
"Assuming the current definition of ~S is correct, and~@\n"
"\t\t      that the loaded code doesn't care about the ~\n"
"\t\t      incompatibility."
msgstr ""

#: target:code/class.lisp
msgid "Topological sort failed due to constraint on ~S."
msgstr ""

#: target:code/class.lisp
msgid "Something strange with forward layout for ~S:~%  ~S"
msgstr ""

#: target:code/alieneval.lisp
msgid "No alien type class ~S"
msgstr ""

#: target:code/alieneval.lisp
msgid "No method ~S"
msgstr ""

#: target:code/alieneval.lisp
msgid ""
"Parse the list structure TYPE as an alien type specifier and return\n"
"   the resultant alien-type structure."
msgstr ""

#: target:code/alieneval.lisp
msgid "Unknown alien type: ~S"
msgstr ""

#: target:code/alieneval.lisp
msgid "No translator for primitive alien type ~S?"
msgstr ""

#: target:code/alieneval.lisp
msgid "Definition missing for alien type ~S?"
msgstr ""

#: target:code/alieneval.lisp
msgid "Attempt to multiple define ~A ~S."
msgstr ""

#: target:code/alieneval.lisp
msgid "Attempt to shadow definition of ~A ~S."
msgstr ""

#: target:code/alieneval.lisp
msgid ""
"Convert the alien-type structure TYPE back into a list specification of\n"
"   the type."
msgstr ""

#: target:compiler/x86/c-call.lisp target:code/alieneval.lisp
msgid "Method ~S not defined for ~S"
msgstr ""

#: target:code/alieneval.lisp
msgid ""
"Define the alien type NAME to be equivalent to TYPE.  Name may be NIL for\n"
"   STRUCT and UNION types, in which case the name is taken from the type\n"
"   specifier."
msgstr ""

#: target:code/alieneval.lisp
msgid "Redefining ~A ~S to be:~%  ~S,~%was:~%  ~S"
msgstr ""

#: target:code/alieneval.lisp
msgid "~S is a built-in alien type."
msgstr ""

#: target:code/alieneval.lisp
msgid "Redefining ~S to be:~%  ~S,~%was~%  ~S"
msgstr ""

#: target:code/alieneval.lisp
msgid "Return T iff TYPE1 and TYPE2 describe equivalent alien types."
msgstr ""

#: target:code/alieneval.lisp
msgid ""
"Return T iff the alien type TYPE1 is a subtype of TYPE2.  Currently, the\n"
"   only supported subtype relationships are that any pointer type is a\n"
"   subtype of (* t), and any array type's first dimension will match \n"
"   (array <eltype> nil ...).  Otherwise, the two types have to be\n"
"   ALIEN-TYPE-=."
msgstr ""

#: target:code/alieneval.lisp
msgid "Return T iff OBJECT is an alien of type TYPE."
msgstr ""

#: target:code/alieneval.lisp
msgid "Cannot represent ~S typed aliens."
msgstr ""

#: target:code/alieneval.lisp
msgid "Cannot pass aliens of type ~S as arguments to call-out"
msgstr ""

#: target:code/alieneval.lisp
msgid "Cannot return aliens of type ~S from call-out"
msgstr ""

#: target:code/alieneval.lisp
msgid "Cannot extract ~D bit integers."
msgstr ""

#: target:code/alieneval.lisp
msgid "Redefining alien enum ~S"
msgstr ""

#: target:code/alieneval.lisp
msgid "Unknown enum type: ~S"
msgstr ""

#: target:code/alieneval.lisp
msgid "Empty enum type: ~S"
msgstr ""

#: target:code/alieneval.lisp
msgid "An enumeration must contain at least one element."
msgstr ""

#: target:code/alieneval.lisp
msgid "Enumeration element ~S is not a keyword."
msgstr ""

#: target:code/alieneval.lisp
msgid "Element value ~S is not an integer."
msgstr ""

#: target:code/alieneval.lisp
msgid "Element value ~S used more than once."
msgstr ""

#: target:code/alieneval.lisp
msgid "Enumeration element ~S used more than once."
msgstr ""

#: target:code/alieneval.lisp
msgid "Can't represent enums needing more than 32 bits."
msgstr ""

#: target:code/alieneval.lisp
msgid "Cannot deposit aliens of type ~S (unknown size)."
msgstr ""

#: target:code/alieneval.lisp
msgid "First dimension is not a non-negative fixnum or NIL: ~S"
msgstr ""

#: target:code/alieneval.lisp
msgid "Dimension is not a non-negative fixnum: ~S"
msgstr ""

#: target:code/alieneval.lisp
msgid "Unknown size: ~S"
msgstr ""

#: target:code/alieneval.lisp
msgid "Unknown alignment: ~S"
msgstr ""

#: target:code/alieneval.lisp
msgid "A hash table used to detect cycles while comparing record types."
msgstr ""

#: target:code/alieneval.lisp
msgid ""
"Test if TYPE1 and TYPE2 are in the *MATCH-HISTORY*.\n"
"If so return true; otherwise call ALTERNATIVE."
msgstr ""

#: target:code/alieneval.lisp
msgid "Cannot use values types here."
msgstr ""

#: target:code/alieneval.lisp
msgid "Badly formed alien name."
msgstr ""

#: target:code/alieneval.lisp
msgid ""
"Define NAME as an external alien variable of type TYPE.  NAME should be\n"
"   a list of a string holding the alien name and a symbol to use as the "
"Lisp\n"
"   name.  If NAME is just a symbol or string, then the other name is "
"guessed\n"
"   from the one supplied."
msgstr ""

#: target:code/alieneval.lisp
msgid ""
"Access the alien variable named NAME, assuming it is of type TYPE.  This\n"
"   is SETFable."
msgstr ""

#: target:code/alieneval.lisp
msgid ""
"Establish some local alien variables.  Each BINDING is of the form:\n"
"     VAR TYPE [ ALLOCATION ] [ INITIAL-VALUE | EXTERNAL-NAME ]\n"
"   ALLOCATION should be one of:\n"
"     :LOCAL (the default)\n"
"       The alien is allocated on the stack, and has dynamic extent.\n"
"     :STATIC\n"
"       The alien is allocated on the heap, and has infinate extent.  The "
"alien\n"
"       is allocated at load time, so the same piece of memory is used each "
"time\n"
"       this form executes.\n"
"     :EXTERN\n"
"       No alien is allocated, but VAR is established as a local name for\n"
"       the external alien given by EXTERNAL-NAME."
msgstr ""

#: target:code/alieneval.lisp
msgid ""
"Return true if X (which must be an Alien pointer) is null, false otherwise."
msgstr ""

#: target:code/alieneval.lisp
msgid ""
"Convert the System-Area-Pointer SAP to an Alien of the specified Type (not\n"
"   evaluated.)  Type must be pointer-like."
msgstr ""

#: target:code/alieneval.lisp
msgid "Cannot make aliens of type ~S out of SAPs"
msgstr ""

#: target:code/alieneval.lisp
msgid "Return a System-Area-Pointer pointing to Alien's data."
msgstr ""

#: target:code/alieneval.lisp
msgid ""
"Allocate an alien of type TYPE and return an alien pointer to it.  If SIZE\n"
"   is supplied, how it is interpreted depends on TYPE.  If TYPE is an array\n"
"   type, SIZE is used as the first dimension for the allocated array.  If "
"TYPE\n"
"   is not an array, then SIZE is the number of elements to allocate.  The\n"
"   memory is allocated using ``malloc'', so it can be passed to foreign\n"
"   functions which use ``free''."
msgstr ""

#: target:code/alieneval.lisp
msgid "Size of ~S unknown."
msgstr ""

#: target:code/alieneval.lisp
msgid "Alignment of ~S unknown."
msgstr ""

#: target:code/alieneval.lisp
msgid "Cannot override the size of zero-dimensional arrays."
msgstr ""

#: target:code/alieneval.lisp
msgid ""
"Dispose of the storage pointed to by ALIEN.  ALIEN must have been allocated\n"
"   by MAKE-ALIEN or ``malloc''."
msgstr ""

#: target:code/alieneval.lisp
msgid "No slot named ~S in ~S"
msgstr ""

#: target:code/alieneval.lisp
msgid ""
"Extract SLOT from the Alien STRUCT or UNION ALIEN.  May be set with SETF."
msgstr ""

#: target:code/alieneval.lisp
msgid "Incorrect number of indices when derefing ~S: ~D"
msgstr ""

#: target:code/alieneval.lisp
msgid ""
"De-reference an Alien pointer or array.  If an array, the indices are used\n"
"   as the indices of the array element to access.  If a pointer, one index "
"can\n"
"   optionally be specified, giving the equivalent of C pointer arithmetic."
msgstr ""

#: target:code/alieneval.lisp
msgid "Something is wrong; local-alien-info not found: ~S"
msgstr ""

#: target:code/alieneval.lisp
msgid "~S isn't forced to memory.  Something went wrong."
msgstr ""

#: target:code/alieneval.lisp
msgid ""
"Return an Alien pointer to the data addressed by Expr, which must be a call\n"
"   to SLOT or DEREF, or a reference to an Alien variable."
msgstr ""

#: target:code/alieneval.lisp
msgid "~S is not a valid L-value"
msgstr ""

#: target:code/alieneval.lisp
msgid "Something is wrong, local-alien-info not found: ~S"
msgstr ""

#: target:code/alieneval.lisp
msgid ""
"Convert ALIEN to an Alien of the specified TYPE (not evaluated).  Both "
"types\n"
"   must be Alien array, pointer or function types."
msgstr ""

#: target:code/alieneval.lisp
msgid "~S cannot be cast."
msgstr ""

#: target:code/alieneval.lisp
msgid "Cannot cast to alien type ~S"
msgstr ""

#: target:code/alieneval.lisp
msgid ""
"Return the size of the alien type TYPE.  UNITS specifies the units to\n"
"   use and can be either :BITS, :BYTES, or :WORDS."
msgstr ""

#: target:code/alieneval.lisp
msgid "Unknown size for alien type ~S."
msgstr ""

#: target:code/alieneval.lisp
msgid ""
"Call the foreign function ALIEN with the specified arguments.  ALIEN's\n"
"   type specifies the argument and result types."
msgstr ""

#: target:code/alieneval.lisp
msgid "Wrong number of arguments for ~S~%Expected ~D, got ~D."
msgstr ""

#: target:code/alieneval.lisp
msgid "~S is not an alien function."
msgstr ""

#: target:code/alieneval.lisp
msgid ""
"Def-Alien-Routine Name Result-Type\n"
"                    {(Arg-Name Arg-Type [Style])}*\n"
"\n"
"  Define a foreign interface function for the routine with the specified "
"Name,\n"
"  which may be either a string, symbol or list of the form (string symbol).\n"
"  Return-Type is the Alien type for the function return value.  VOID may be\n"
"  used to specify a function with no result.\n"
"\n"
"  The remaining forms specify individual arguments that are passed to the\n"
"  routine.  Arg-Name is a symbol that names the argument, primarily for\n"
"  documentation.  Arg-Type is the C-Type of the argument.  Style specifies "
"the\n"
"  way that the argument is passed.\n"
"\n"
"  :IN\n"
"        An :In argument is simply passed by value.  The value to be passed "
"is\n"
"        obtained from argument(s) to the interface function.  No values are\n"
"        returned for :In arguments.  This is the default mode.\n"
"\n"
"  :OUT\n"
"        The specified argument type must be a pointer to a fixed sized "
"object.\n"
"        A pointer to a preallocated object is passed to the routine, and "
"the\n"
"        the object is accessed on return, with the value being returned "
"from\n"
"        the interface function.  :OUT and :IN-OUT cannot be used with "
"pointers\n"
"        to arrays, records or functions.\n"
"\n"
"  :COPY\n"
"        Similar to :IN, except that the argument values are stored in on\n"
"        the stack, and a pointer to the object is passed instead of\n"
"        the values themselves.\n"
"\n"
"  :IN-OUT\n"
"        A combination of :OUT and :COPY.  A pointer to the argument is "
"passed,\n"
"        with the object being initialized from the supplied argument and\n"
"        the return value being determined by accessing the object on return."
msgstr ""

#: target:code/alieneval.lisp
msgid "Bogus argument style ~S in ~S."
msgstr ""

#: target:code/alieneval.lisp
msgid "Can't use :out or :in-out on pointer-like type:~%  ~S"
msgstr ""

#: target:code/alieneval.lisp
msgid ""
"A callback consists of a piece assembly code -- the trampoline --\n"
"and a lisp function.  We store the function type (including return\n"
"type and arg types), so we can detect incompatible redefinitions."
msgstr ""

#: target:code/alieneval.lisp
msgid "Vector of all callbacks."
msgstr ""

#: target:pcl/simple-streams/string.lisp target:compiler/tn.lisp
#: target:compiler/main.lisp target:code/describe.lisp
#: target:code/debug-int.lisp target:code/debug-info.lisp
#: target:code/foreign-linkage.lisp target:code/reader.lisp
#: target:code/stream.lisp target:code/hash-new.lisp target:code/array.lisp
#: target:code/alieneval.lisp
msgid "~S is not an array with a fill-pointer."
msgstr ""

#: target:code/alieneval.lisp
msgid "Unable to mprotect ~S bytes (~S) at ~S (~S).  Callbacks may not work."
msgstr ""

#: target:code/alieneval.lisp
msgid "Return the trampoline pointer for the callback NAME."
msgstr ""

#: target:code/alieneval.lisp
msgid ""
"~\n"
"Attempt to redefine callback with incompatible return type.\n"
"   Old type was: ~A \n"
"    New type is: ~A"
msgstr ""

#: target:code/alieneval.lisp
msgid ""
"~\n"
"Create new trampoline (old trampoline calls old lisp function)."
msgstr ""

#: target:code/alieneval.lisp
msgid "Unsupported argument type: ~A"
msgstr ""

#: target:code/alieneval.lisp
msgid "Unsupported return type: ~A"
msgstr ""

#: target:code/alieneval.lisp
msgid ""
"(defcallback NAME (RETURN-TYPE {(ARG-NAME ARG-TYPE)}*)\n"
"     {doc-string} {decls}* {FORM}*)\n"
"\n"
"Define a function which can be called by foreign code.  The pointer\n"
"returned by (callback NAME), when called by foreign code, invokes the\n"
"lisp function.  The lisp function expects alien arguments of the\n"
"specified ARG-TYPEs and returns an alien of type RETURN-TYPE.\n"
"\n"
"If (callback NAME) is already a callback function pointer, its value\n"
"is not changed (though it's arranged that an updated version of the\n"
"lisp callback function will be called).  This feature allows for\n"
"incremental redefinition of callback functions."
msgstr ""

#: target:code/bit-bash.lisp
msgid "The number of bits to process at a time."
msgstr ""

#: target:code/bit-bash.lisp
msgid "The maximum number of bits that can be dealt with during a single call."
msgstr ""

#: target:code/bit-bash.lisp
msgid ""
"Shift NUMBER by COUNT bits, adding zero bits at the ``end'' and removing\n"
"  bits from the ``start.''  On big-endian machines this is a left-shift and\n"
"  on little-endian machines this is a right-shift.  Note: only the low 5/6 "
"bits\n"
"  of count are significant."
msgstr ""

#: target:code/bit-bash.lisp
msgid ""
"Shift NUMBER by COUNT bits, adding zero bits at the ``start'' and removing\n"
"  bits from the ``end.''  On big-endian machines this is a right-shift and\n"
"  on little-endian machines this is a left-shift."
msgstr ""

#: target:code/bit-bash.lisp
msgid ""
"Produce a mask that contains 1's for the COUNT ``start'' bits and 0's for\n"
"  the remaining ``end'' bits.  Only the lower 5 bits of COUNT are "
"significant."
msgstr ""

#: target:code/bit-bash.lisp
msgid ""
"Produce a mask that contains 1's for the COUNT ``end'' bits and 0's for\n"
"  the remaining ``start'' bits.  Only the lower 5 bits of COUNT are\n"
"  significant."
msgstr ""

#: target:code/bit-bash.lisp
msgid "Align the SAP to a word boundry, and update the offset accordingly."
msgstr ""

#: target:code/bit-bash.lisp
msgid ""
"Fill DST with VALUE starting at DST-OFFSET and continuing for LENGTH bits."
msgstr ""

#: target:code/byte-interp.lisp
msgid "This is the interpreter's evaluation stack."
msgstr ""

#: target:code/byte-interp.lisp
msgid "This is the next free element of the interpreter's evaluation stack."
msgstr ""

#: target:code/byte-interp.lisp
msgid "Undefined XOP."
msgstr ""

#: target:code/byte-interp.lisp
msgid "Unbound variable: ~S"
msgstr ""

#: target:code/byte-interp.lisp
msgid "Non-list argument to CAR: ~S"
msgstr ""

#: target:code/byte-interp.lisp
msgid "Non-list argument to CDR: ~S"
msgstr ""

#: target:code/byte-interp.lisp
msgid "Unknown inline function, id=~D"
msgstr ""

#: target:code/byte-interp.lisp
msgid "Wrong number of arguments."
msgstr ""

#: target:code/byte-interp.lisp
msgid "Not enough arguments."
msgstr ""

#: target:code/byte-interp.lisp
msgid "Too many arguments."
msgstr ""

#: target:code/byte-interp.lisp
msgid "Odd number of keyword arguments."
msgstr ""

#: target:code/byte-interp.lisp
msgid "Unknown keyword: ~S"
msgstr ""

#: target:code/byte-interp.lisp
msgid "function-end breakpoints not supported."
msgstr ""

#: target:code/array.lisp
msgid "The exclusive upper bound on the rank of an array."
msgstr ""

#: target:code/array.lisp
msgid "The exclusive upper bound any given dimension of an array."
msgstr ""

#: target:code/array.lisp
msgid "The exclusive upper bound on the total number of elements in an array."
msgstr ""

#: target:code/array.lisp
msgid "Start ~D is greater than end ~D."
msgstr ""

#: target:code/array.lisp
msgid "End ~D is greater than total size ~D."
msgstr ""

#: target:code/array.lisp
msgid ""
"List of weak-pointers to static vectors.  Needed for GCing static vectors"
msgstr ""

#: target:code/array.lisp
msgid "Cannot make a static array of element type ~S"
msgstr ""

#: target:code/array.lisp
msgid "Failed to allocate space for static array of length ~S of type ~S"
msgstr ""

#: target:code/array.lisp
msgid ""
"Creates an array of the specified Dimensions and properties.  See the\n"
"  manual for details.\n"
"\n"
"  :Element-type\n"
"      The type of objects that the array can hold \n"
"  :Initial-element\n"
"      Each element of the array is initialized to this value, if supplied.\n"
"      If not supplied, 0 of the appropriate type is used.\n"
"  :Initial-contents\n"
"      The contents of the array are initialized to this.\n"
"  :Adjustable\n"
"      If non-Nil, make an expressly adjustable array.\n"
"  :Fill-pointer\n"
"      For one-dimensional array, set the fill-pointer to the given value.\n"
"      If T, use the actual length of the array.\n"
"  :Displaced-to\n"
"      Create an array that is displaced to the target array specified\n"
"      by :displaced-to.\n"
"  :Displaced-index-offset\n"
"      Index offset to the displaced array.  That is, index 0 of this array "
"is\n"
"      actually index displaced-index-offset of the target displaced array. \n"
"  :Allocation\n"
"      How to allocate the array.  If :MALLOC, a static, nonmovable array is\n"
"      created.  This array is created by calling malloc."
msgstr ""

#: target:code/array.lisp
msgid "Can't specify :displaced-index-offset without :displaced-to"
msgstr ""

#: target:code/array.lisp
msgid "Cannot make an adjustable static array"
msgstr ""

#: target:code/array.lisp
msgid "Cannot make a displaced array static"
msgstr ""

#: target:code/array.lisp
msgid ""
"Cannot specify both :initial-element and ~\n"
"\t\t:initial-contents"
msgstr ""

#: target:code/array.lisp
msgid ""
"~D elements in the initial-contents, but the ~\n"
"\t\tvector length is ~D."
msgstr ""

#: target:code/array.lisp
msgid "Only vectors can have fill pointers."
msgstr ""

#: target:code/array.lisp
msgid "Invalid fill-pointer ~D"
msgstr ""

#: target:code/array.lisp
msgid ""
"Neither :initial-element nor :initial-contents ~\n"
"\t\t   can be specified along with :displaced-to"
msgstr ""

#: target:code/array.lisp
msgid ""
"One can't displace an array of type ~S into ~\n"
"                           another of type ~S."
msgstr ""

#: target:code/array.lisp
msgid "~S doesn't have enough elements."
msgstr ""

#: target:code/array.lisp
msgid "~&Freeing foreign vector at #x~X~%"
msgstr ""

#: target:code/array.lisp
msgid "Finalizing static vectors ~S~%"
msgstr ""

#: target:code/array.lisp
msgid "static vector ~A.  header = ~X~%"
msgstr ""

#: target:code/array.lisp
msgid "  static vector ~A in use~%"
msgstr ""

#: target:code/array.lisp
msgid "  Free static vector ~A~%"
msgstr ""

#: target:code/array.lisp
msgid ""
"Cannot supply both :initial-contents and :initial-element to\n"
"            either make-array or adjust-array."
msgstr ""

#: target:code/array.lisp
msgid "~S cannot be used to initialize an array of type ~S."
msgstr ""

#: target:code/array.lisp
msgid ""
"Malformed :initial-contents.  ~S is not a ~\n"
"\t\t\t        sequence, but ~D more layer~:P needed."
msgstr ""

#: target:code/array.lisp
msgid ""
"Malformed :initial-contents.  Dimension of ~\n"
"\t\t\t        axis ~D is ~D, but ~S is ~D long."
msgstr ""

#: target:code/array.lisp
msgid "Constructs a simple-vector from the given objects."
msgstr ""

#: target:code/array.lisp
msgid "Wrong number of subscripts, ~D, for array of rank ~D"
msgstr ""

#: target:code/array.lisp
msgid "Invalid index ~D~[~;~:; on axis ~:*~D~] in ~S"
msgstr ""

#: target:code/array.lisp
msgid "Invalid index ~D in ~S"
msgstr ""

#: target:code/array.lisp
msgid "Returns T if the Subscipts are in bounds for the Array, Nil otherwise."
msgstr ""

#: target:code/array.lisp
msgid "Returns the element of the Array specified by the Subscripts."
msgstr ""

#: target:code/array.lisp
msgid ""
"Returns the element of array corressponding to the row-major index.  This "
"is\n"
"   SETF'able."
msgstr ""

#: target:code/array.lisp
msgid "Returns the Index'th element of the given Simple-Vector."
msgstr ""

#: target:code/array.lisp
msgid "Returns the bit from the Bit-Array at the specified Subscripts."
msgstr ""

#: target:code/array.lisp
msgid "Returns the bit from the Simple-Bit-Array at the specified Subscripts."
msgstr ""

#: target:code/array.lisp
msgid "Returns the type of the elements of the array"
msgstr ""

#: target:code/array.lisp
msgid "Returns the number of dimensions of the Array."
msgstr ""

#: target:code/array.lisp
msgid "Returns length of dimension Axis-Number of the Array."
msgstr ""

#: target:code/array.lisp
msgid "Vector axis is not zero: ~S"
msgstr ""

#: target:code/array.lisp
msgid "~D is too big; ~S only has ~D dimension~:P"
msgstr ""

#: target:code/array.lisp
msgid "Returns a list whose elements are the dimensions of the array"
msgstr ""

#: target:code/array.lisp
msgid "Returns the total number of elements in the Array."
msgstr ""

#: target:code/array.lisp
msgid ""
"Returns values of :displaced-to and :displaced-index-offset options to\n"
"   make-array, or the defaults nil and 0 if not a displaced array."
msgstr ""

#: target:code/array.lisp
msgid ""
"Returns T if (adjust-array array...) would return an array identical\n"
"   to the argument, this happens for complex arrays."
msgstr ""

#: target:code/array.lisp
msgid "Returns T if the given Array has a fill pointer, or Nil otherwise."
msgstr ""

#: target:code/array.lisp
msgid "Returns the Fill-Pointer of the given Vector."
msgstr ""

#: target:code/array.lisp
msgid "New fill pointer, ~S, is larger than the length of the vector."
msgstr ""

#: target:code/array.lisp
msgid ""
"Attempts to set the element of Array designated by the fill pointer\n"
"   to New-El and increment fill pointer by one.  If the fill pointer is\n"
"   too large, Nil is returned, otherwise the index of the pushed element "
"is \n"
"   returned."
msgstr ""

#: target:code/array.lisp
msgid ""
"Like Vector-Push except that if the fill pointer gets too large, the\n"
"   Array is extended rather than Nil being returned."
msgstr ""

#: target:code/array.lisp
msgid ""
"Attempts to decrease the fill-pointer by 1 and return the element\n"
"   pointer to by the new fill pointer.  If the original value of the fill\n"
"   pointer is 0, an error occurs."
msgstr ""

#: target:code/array.lisp
msgid "Nothing left to pop."
msgstr ""

#: target:code/array.lisp
msgid "Adjusts the Array's dimensions to the given Dimensions and stuff."
msgstr ""

#: target:code/array.lisp
msgid "Number of dimensions not equal to rank of array."
msgstr ""

#: target:code/array.lisp
msgid "New element type, ~S, is incompatible with old."
msgstr ""

#: target:code/array.lisp
msgid "Static arrays are not adjustable."
msgstr ""

#: target:code/array.lisp
msgid "Multidimensional arrays can't have fill pointers."
msgstr ""

#: target:code/array.lisp
msgid ""
"Initial contents may not be specified with ~\n"
"\t\t the :initial-element or :displaced-to option."
msgstr ""

#: target:code/array.lisp
msgid ""
"The :initial-element option may not be specified ~\n"
"\t       with :displaced-to."
msgstr ""

#: target:code/array.lisp
msgid ""
"One can't displace an array of type ~S into another of ~\n"
"\t               type ~S."
msgstr ""

#: target:code/array.lisp
msgid "The :displaced-to array is too small."
msgstr ""

#: target:code/array.lisp
msgid ""
"Cannot adjust-array an array (~S) to a size (~S) that is ~\n"
"\t            smaller than it's fill pointer (~S)."
msgstr ""

#: target:code/array.lisp
msgid ""
"Cannot supply a non-NIL value (~S) for :fill-pointer ~\n"
"\t   in adjust-array unless the array (~S) was originally ~\n"
" \t   created with a fill pointer."
msgstr ""

#: target:code/array.lisp
msgid ""
"Cannot supply a value for :fill-pointer (~S) that is larger ~\n"
"\t     than the new length of the vector (~S)."
msgstr ""

#: target:code/array.lisp
msgid "Bogus value for :fill-pointer in adjust-array: ~S"
msgstr ""

#: target:code/array.lisp
msgid ""
"Destructively alters the Vector, changing its length to New-Size, which\n"
"   must be less than or equal to its current size."
msgstr ""

#: target:code/array.lisp
msgid "Fills in array header with provided information.  Returns array."
msgstr ""

#: target:code/array.lisp
msgid "~S and ~S do not have the same dimensions."
msgstr "~S 와 ~S 는 그 요소의 수가 다르다."

#: target:code/array.lisp
msgid ""
"Performs a bit-wise logical NOT on the elements of BIT-ARRAY,\n"
"  putting the results in RESULT-BIT-ARRAY.  If RESULT-BIT-ARRAY is T,\n"
"  BIT-ARRAY is used.  If RESULT-BIT-ARRAY is NIL or omitted, a new array is\n"
"  created.  Both arrays must have the same rank and dimensions."
msgstr ""

#: target:code/bsd-os.lisp
msgid "Unix system call getrusage failed: ~A."
msgstr ""

#: target:code/bsd-os.lisp
msgid "Getpagesize failed: ~A"
msgstr ""

#: target:code/bignum.lisp
msgid ""
"When the bignum pieces are smaller than this many words, we use the\n"
"classical multiplication algorithm instead of recursing all the way\n"
"down to individual words."
msgstr ""

#: target:code/bignum.lisp
msgid "Use Karatsuba if the bignums have at least this many bits"
msgstr ""

#: target:code/bignum.lisp
msgid "WITH-BIGNUM-BUFFERS ({(var size [init])}*) Form*"
msgstr ""

#: target:code/bignum.lisp
msgid "Unexpected zero bignums?"
msgstr ""

#: target:code/bignum.lisp
msgid "Can't represent result of left shift."
msgstr ""

#: target:code/bignum.lisp
msgid "Too large to be represented as a ~S:~%  ~S"
msgstr ""

#: target:code/float-trap.lisp
msgid "Unknown float trap kind: ~S."
msgstr ""

#: target:code/float-trap.lisp
msgid ""
"This function sets options controlling the floating-point hardware.  If a\n"
"  keyword is not supplied, then the current value is preserved.  Possible\n"
"  keywords:\n"
"\n"
"   :TRAPS\n"
"       A list of the exception conditions that should cause traps.  "
"Possible\n"
"       exceptions are :UNDERFLOW, :OVERFLOW, :INEXACT, :INVALID,\n"
"       :DIVIDE-BY-ZERO, and on the X86 :DENORMALIZED-OPERAND. Initially\n"
"       all traps except :INEXACT are enabled.\n"
"\n"
"   :ROUNDING-MODE\n"
"       The rounding mode to use when the result is not exact.  Possible "
"values\n"
"       are :NEAREST, :POSITIVE-INFINITY, :NEGATIVE-INFINITY and :ZERO.\n"
"       Initially, the rounding mode is :NEAREST.\n"
"\n"
"   :CURRENT-EXCEPTIONS\n"
"   :ACCRUED-EXCEPTIONS\n"
"       These arguments allow setting of the exception flags.  The main use "
"is\n"
"       setting the accrued exceptions to NIL to clear them.\n"
"\n"
"   :FAST-MODE\n"
"       Set the hardware's \"fast mode\" flag, if any.  When set, IEEE\n"
"       conformance or debuggability may be impaired.  Some machines may not\n"
"       have this feature, in which case the value is always NIL.\n"
"\n"
"   GET-FLOATING-POINT-MODES may be used to find the floating point modes\n"
"   currently in effect."
msgstr ""

#: target:code/float-trap.lisp
msgid "Unknown rounding mode: ~S."
msgstr ""

#: target:code/float-trap.lisp
msgid ""
"This function returns a list representing the state of the floating point\n"
"  modes.  The list is in the same format as the keyword arguments to\n"
"  SET-FLOATING-POINT-MODES, i.e. \n"
"      (apply #'set-floating-point-modes (get-floating-point-modes))\n"
"\n"
"  sets the floating point modes to their current values (and thus is a no-"
"op)."
msgstr ""

#: target:code/float-trap.lisp
msgid ""
"Current-Float-Trap Trap-Name*\n"
"  Return true if any of the named traps are currently trapped, false\n"
"  otherwise."
msgstr ""

#: target:code/float-trap.lisp
msgid "SIGFPE with no exceptions currently enabled?"
msgstr ""

#: target:code/float-trap.lisp
msgid ""
"Execute BODY with the floating point exceptions listed in TRAPS\n"
"  masked (disabled).  TRAPS should be a list of possible exceptions\n"
"  which includes :UNDERFLOW, :OVERFLOW, :INEXACT, :INVALID and\n"
"  :DIVIDE-BY-ZERO and on the X86 :DENORMALIZED-OPERAND. The respective\n"
"  accrued exceptions are cleared at the start of the body to support\n"
"  their testing within, and restored on exit."
msgstr ""

#: target:code/float.lisp
msgid "Return true if the float X is denormalized."
msgstr ""

#: target:code/float.lisp
msgid ""
"Returns a non-negative number of significant digits in it's float argument.\n"
"  Will be less than FLOAT-DIGITS if denormalized or zero."
msgstr ""

#: target:code/float.lisp
msgid ""
"Returns a floating-point number that has the same sign as\n"
"   float1 and, if float2 is given, has the same absolute value\n"
"   as float2."
msgstr ""

#: target:code/float.lisp
msgid ""
"Returns a non-negative number of radix-b digits used in the\n"
"   representation of it's argument.  See Common Lisp: The Language\n"
"   by Guy Steele for more details."
msgstr ""

#: target:code/float.lisp
msgid ""
"Returns (as an integer) the radix b of its floating-point\n"
"   argument."
msgstr ""

#: target:code/irrat.lisp target:code/float.lisp
msgid "Can't decode NAN or infinity: ~S."
msgstr ""

#: target:code/float.lisp
msgid ""
"Returns three values:\n"
"   1) an integer representation of the significand.\n"
"   2) the exponent for the power of 2 that the significand must be "
"multiplied\n"
"      by to get the actual value.  This differs from the DECODE-FLOAT "
"exponent\n"
"      by FLOAT-DIGITS, since the significand has been scaled to have all "
"its\n"
"      digits before the radix point.\n"
"   3) -1 or 1 (i.e. the sign of the argument.)"
msgstr ""

#: target:code/float.lisp
msgid ""
"Returns three values:\n"
"   1) a floating-point number representing the significand.  This is always\n"
"      between 0.5 (inclusive) and 1.0 (exclusive).\n"
"   2) an integer representing the exponent.\n"
"   3) -1.0 or 1.0 (i.e. the sign of the argument.)"
msgstr ""

#: target:code/float.lisp
msgid ""
"Returns the value (* f (expt (float 2 f) ex)), but with no unnecessary loss\n"
"  of precision or overflow."
msgstr ""

#: target:code/float.lisp
msgid ""
"Converts any REAL to a float.  If OTHER is not provided, it returns a\n"
"  SINGLE-FLOAT if NUMBER is not already a FLOAT.  If OTHER is provided, the\n"
"  result is the same float format as OTHER."
msgstr ""

#: target:code/float.lisp
msgid ""
"RATIONAL produces a rational number for any real numeric argument.  This is\n"
"  more efficient than RATIONALIZE, but it assumes that floating-point is\n"
"  completely accurate, giving a result that isn't as pretty."
msgstr ""

#: target:code/float.lisp
msgid ""
"Converts any REAL to a RATIONAL.  Floats are converted to a simple rational\n"
"  representation exploiting the assumption that floats are only accurate to\n"
"  their precision.  RATIONALIZE (and also RATIONAL) preserve the invariant:\n"
"      (= x (float (rationalize x) x))"
msgstr ""

#: target:code/char.lisp
msgid "The upper exclusive bound on values produced by CHAR-CODE."
msgstr ""

#: target:code/char.lisp
msgid "The upper exclusive bound on the value of a Unicode codepoint"
msgstr ""

#: target:code/char.lisp
msgid ""
"This is the alist of (character-name . character) for characters with\n"
"  long names.  The first name in this list for a given character is used\n"
"  on typeout and is the preferred form for input."
msgstr ""

#: target:code/char.lisp
msgid "Returns the integer code of CHAR."
msgstr ""

#: target:code/char.lisp
msgid ""
"Returns the integer code of CHAR.  This is the same as char-code, as\n"
"   CMU Common Lisp does not implement character bits or fonts."
msgstr ""

#: target:code/char.lisp
msgid "Returns the character with the code CODE."
msgstr ""

#: target:code/char.lisp
msgid ""
"Coerces its argument into a character object if possible.  Accepts\n"
"  characters, strings and symbols of length 1."
msgstr ""

#: target:code/char.lisp
msgid "String is not of length one: ~S"
msgstr ""

#: target:code/char.lisp
msgid "Symbol name is not of length one: ~S"
msgstr ""

#: target:code/char.lisp
msgid "~S cannot be coerced to a character."
msgstr ""

#: target:code/char.lisp
msgid ""
"Given a character object, char-name returns the name for that\n"
"  object (a symbol)."
msgstr ""

#: target:code/char.lisp
msgid ""
"Given an argument acceptable to string, name-char returns a character\n"
"  object whose name is that symbol, if one exists, otherwise NIL."
msgstr ""

#: target:code/char.lisp
msgid ""
"The argument must be a character object.  Standard-char-p returns T if the\n"
"   argument is a standard character -- one of the 95 ASCII printing "
"characters\n"
"   or <return>."
msgstr ""

#: target:code/char.lisp
msgid ""
"Return T if and only if THING is a standard-char.  Differs from\n"
"  standard-char-p in that THING doesn't have to be a character."
msgstr ""

#: target:code/char.lisp
msgid ""
"The argument must be a character object.  Graphic-char-p returns T if the\n"
"  argument is a printing character, otherwise returns NIL."
msgstr ""

#: target:code/char.lisp
msgid ""
"The argument must be a character object.  Alpha-char-p returns T if the\n"
"  argument is an alphabetic character; otherwise NIL."
msgstr ""

#: target:code/char.lisp
msgid ""
"The argument must be a character object; upper-case-p returns T if the\n"
"  argument is an upper-case character, NIL otherwise."
msgstr ""

#: target:code/char.lisp
msgid ""
"The argument must be a character object; lower-case-p returns T if the \n"
"  argument is a lower-case character, NIL otherwise."
msgstr ""

#: target:code/char.lisp
msgid ""
"The argument must be a character object; title-case-p returns T if the\n"
"  argument is a title-case character, NIL otherwise."
msgstr ""

#: target:code/char.lisp
msgid ""
"The argument must be a character object.  Both-case-p returns T if the\n"
"  argument is an alphabetic character and if the character exists in\n"
"  both upper and lower case.  For ASCII, this is the same as Alpha-char-p."
msgstr ""

#: target:code/char.lisp
msgid ""
"If char is a digit in the specified radix, returns the fixnum for\n"
"  which that digit stands, else returns NIL.  Radix defaults to 10\n"
"  (decimal)."
msgstr ""

#: target:code/char.lisp
msgid ""
"Given a character-object argument, alphanumericp returns T if the\n"
"  argument is either numeric or alphabetic."
msgstr ""

#: target:code/char.lisp
msgid "Returns T if all of its arguments are the same character."
msgstr ""

#: target:code/char.lisp
msgid "Returns T if no two of its arguments are the same character."
msgstr ""

#: target:code/char.lisp
msgid "Returns T if its arguments are in strictly increasing alphabetic order."
msgstr ""

#: target:code/char.lisp
msgid "Returns T if its arguments are in strictly decreasing alphabetic order."
msgstr ""

#: target:code/char.lisp
msgid ""
"Returns T if its arguments are in strictly non-decreasing alphabetic order."
msgstr ""

#: target:code/char.lisp
msgid ""
"Returns T if its arguments are in strictly non-increasing alphabetic order."
msgstr ""

#: target:code/char.lisp
msgid ""
"Returns T if all of its arguments are the same character.\n"
"   Case is ignored."
msgstr ""

#: target:code/char.lisp
msgid ""
"Returns T if no two of its arguments are the same character.\n"
"   Case is ignored."
msgstr ""

#: target:code/char.lisp
msgid ""
"Returns T if its arguments are in strictly increasing alphabetic order.\n"
"   Case is ignored."
msgstr ""

#: target:code/char.lisp
msgid ""
"Returns T if its arguments are in strictly decreasing alphabetic order.\n"
"   Case is ignored."
msgstr ""

#: target:code/char.lisp
msgid ""
"Returns T if its arguments are in strictly non-decreasing alphabetic order.\n"
"   Case is ignored."
msgstr ""

#: target:code/char.lisp
msgid ""
"Returns T if its arguments are in strictly non-increasing alphabetic order.\n"
"   Case is ignored."
msgstr ""

#: target:code/char.lisp
msgid "Returns CHAR converted to upper-case if that is possible."
msgstr ""

#: target:code/char.lisp
msgid "Returns CHAR converted to title-case if that is possible."
msgstr ""

#: target:code/char.lisp
msgid "Returns CHAR converted to lower-case if that is possible."
msgstr ""

#: target:code/char.lisp
msgid ""
"All arguments must be integers.  Returns a character object that\n"
"  represents a digit of the given weight in the specified radix.  Returns\n"
"  NIL if no such character exists."
msgstr ""

#: target:code/extensions.lisp
msgid ""
"This function can be used as the default value for keyword arguments that\n"
"  must be always be supplied.  Since it is known by the compiler to never\n"
"  return, it will avoid any compile-time type warnings that would result "
"from a\n"
"  default value inconsistent with the declared type.  When this function is\n"
"  called, it signals an error indicating that a required keyword argument "
"was\n"
"  not supplied.  This function is also useful for DEFSTRUCT slot defaults\n"
"  corresponding to required arguments."
msgstr ""

#: target:code/extensions.lisp
msgid "A required keyword argument was not supplied."
msgstr ""

#: target:code/extensions.lisp
msgid ""
"FILE-COMMENT String\n"
"  When COMPILE-FILE sees this form at top-level, it places the constant "
"string\n"
"  in the run-time source location information.  DESCRIBE will print the "
"file\n"
"  comment for the file that a function was defined in.  The string is also\n"
"  textually present in the FASL, so the RCS \"ident\" command can find it,\n"
"  etc."
msgstr ""

#: target:code/extensions.lisp
msgid "See listen.  Any whitespace in the input stream will be flushed."
msgstr ""

#: target:code/extensions.lisp
msgid ""
"Does what one might expect, saving the old values and setting the "
"generalized\n"
"  variables to the new values in sequence.  Unwind-protects and get-setf-"
"method\n"
"  are used to preserve the semantics one might expect in analogy to let*,\n"
"  and the once-only evaluation of subforms."
msgstr ""

#: target:code/extensions.lisp
msgid ""
"Like letf*, but evaluates all the implicit subforms and new values of all\n"
"  the implied setfs before altering any values.  However, the store forms\n"
"  (see get-setf-method) must still be evaluated in sequence.  Uses unwind-\n"
"  protects to protect the environment."
msgstr ""

#: target:code/extensions.lisp
msgid ""
"Causes the output of the indenting Stream to indent More spaces.  More is\n"
"  evaluated twice."
msgstr ""

#: target:code/extensions.lisp
msgid "Just like dolist, but with one-dimensional arrays."
msgstr ""

#: target:code/extensions.lisp
msgid ""
"Iterate Name ({(Var Initial-Value)}*) Declaration* Form*\n"
"  This is syntactic sugar for Labels.  It creates a local function Name "
"with\n"
"  the specified Vars as its arguments and the Declarations and Forms as its\n"
"  body.  This function is then called with the Initial-Values, and the "
"result\n"
"  of the call is return from the macro."
msgstr ""

#: target:code/extensions.lisp
msgid "Malformed iterate variable spec: ~S."
msgstr ""

#: target:code/extensions.lisp
msgid ""
"Collect ({(Name [Initial-Value] [Function])}*) {Form}*\n"
"  Collect some values somehow.  Each of the collections specifies a bunch "
"of\n"
"  things which collected during the evaluation of the body of the form.  "
"The\n"
"  name of the collection is used to define a local macro, a la MACROLET.\n"
"  Within the body, this macro will evaluate each of its arguments and "
"collect\n"
"  the result, returning the current value after the collection is done.  "
"The\n"
"  body is evaluated as a PROGN; to get the final values when you are done, "
"just\n"
"  call the collection macro with no arguments.\n"
"\n"
"  Initial-Value is the value that the collection starts out with, which\n"
"  defaults to NIL.  Function is the function which does the collection.  It "
"is\n"
"  a function which will accept two arguments: the value to be collected and "
"the\n"
"  current collection.  The result of the function is made the new value for "
"the\n"
"  collection.  As a totally magical special-case, the Function may be "
"Collect,\n"
"  which tells us to build a list in forward order; this is the default.  If "
"an\n"
"  Initial-Value is supplied for Collect, the stuff will be rplacd'd onto "
"the\n"
"  end.  Note that Function may be anything that can appear in the "
"functional\n"
"  position, including macros and lambdas."
msgstr ""

#: target:code/extensions.lisp
msgid "Malformed collection specifier: ~S."
msgstr ""

#: target:code/extensions.lisp
msgid ""
"Once-Only ({(Var Value-Expression)}*) Form*\n"
"  Create a Let* which evaluates each Value-Expression, binding a temporary\n"
"  variable to the result, and wrapping the Let* around the result of the\n"
"  evaluation of Body.  Within the body, each Var is bound to the "
"corresponding\n"
"  temporary variable."
msgstr ""

#: target:code/extensions.lisp
msgid "Malformed Once-Only binding spec: ~S."
msgstr ""

#: target:code/extensions.lisp
msgid "Ill-formed ~S -- possibly illegal old style DO?"
msgstr ""

#: target:code/extensions.lisp
msgid "~S step variable is not a symbol: ~S"
msgstr ""

#: target:code/extensions.lisp
msgid "~S is an illegal form for a ~S varlist."
msgstr ""

#: target:code/extensions.lisp
msgid ""
"DO-ANONYMOUS ({(Var [Init] [Step])}*) (Test Exit-Form*) Declaration* Form*\n"
"  Like DO, but has no implicit NIL block.  Each Var is initialized in "
"parallel\n"
"  to the value of the specified Init form.  On subsequent iterations, the "
"Vars\n"
"  are assigned the value of the Step form (if any) in paralell.  The Test "
"is\n"
"  evaluated before each evaluation of the body Forms.  When the Test is "
"true,\n"
"  the Exit-Forms are evaluated as a PROGN, with the result being the value\n"
"  of the DO."
msgstr ""

#: target:code/extensions.lisp
msgid ""
"DO-HASH (Key-Var Value-Var Table [Result]) Declaration* Form*\n"
"   Iterate over the entries in a hash-table."
msgstr ""

#: target:code/extensions.lisp
msgid ""
"DEFINE-HASH-CACHE Name ({(Arg-Name Test-Function)}*) {Key Value}*\n"
"  Define a hash cache that associates some number of argument values to a\n"
"  result value.  The Test-Function paired with each Arg-Name is used to "
"compare\n"
"  the value for that arg in a cache entry with a supplied arg.  The\n"
"  Test-Function must not error when passed NIL as its first arg, but need "
"not\n"
"  return any particular value.  Test-Function may be any thing that can be\n"
"  place in CAR position.\n"
"\n"
"  Name is used to define functions these functions:\n"
"\n"
"  <name>-CACHE-LOOKUP Arg*\n"
"      See if there is an entry for the specified Args in the cache.  The if "
"not\n"
"      present, the :DEFAULT keyword (default NIL) determines the result(s).\n"
"\n"
"  <name>-CACHE-ENTER Arg* Value*\n"
"      Encache the association of the specified args with Value.\n"
"\n"
"  <name>-CACHE-FLUSH-<arg-name> Arg\n"
"      Flush all entries from the cache that have the value Arg for the "
"named\n"
"      arg.\n"
"\n"
"  <name>-CACHE-CLEAR\n"
"      Reinitialize the cache, invalidating all entries and allowing the\n"
"      arguments and result values to be GC'd.\n"
"\n"
"  These other keywords are defined:\n"
"\n"
"  :HASH-BITS <n>\n"
"      The size of the cache as a power of 2.\n"
"\n"
"  :HASH-FUNCTION function\n"
"      Some thing that can be placed in CAR position which will compute a "
"value\n"
"      between 0 and (1- (expt 2 <hash-bits>)).\n"
"\n"
"  :VALUES <n>\n"
"      The number of values cached.\n"
"\n"
"   :INIT-FORM <name>\n"
"      The DEFVAR for creating the cache is enclosed in a form with the\n"
"      specified name.  Default PROGN."
msgstr ""

#: target:code/extensions.lisp
msgid "Number of default values ~S differs from :VALUES ~D."
msgstr ""

#: target:code/extensions.lisp
msgid "Bad arg spec: ~S."
msgstr ""

#: target:code/extensions.lisp
msgid ""
"DEFUN-CACHED (Name {Key Value}*) ({(Arg-Name Test-Function)}*) Form*\n"
"  Some syntactic sugar for defining a function whose values are cached by\n"
"  DEFINE-HASH-CACHE."
msgstr ""

#: target:code/extensions.lisp
msgid ""
"Return an EQ hash of X.  The value of this hash for any given object can "
"(of\n"
"  course) change at arbitary times."
msgstr ""

#: target:code/commandline.lisp
msgid "A list of all the command line arguments after --"
msgstr ""

#: target:code/commandline.lisp
msgid ""
"A list of cmd-switch's representing the arguments used to invoke\n"
"  this process."
msgstr ""

#: target:code/commandline.lisp
msgid "The string name that was used to invoke this process."
msgstr ""

#: target:code/commandline.lisp
msgid "A list of words between the utility name and the first switch."
msgstr ""

#: target:code/commandline.lisp
msgid ""
"A list of strings obtained from the command line that invoked this process."
msgstr ""

#: target:code/commandline.lisp
msgid "An Alist of (\"argument-name\" . demon-function)"
msgstr ""

#: target:code/commandline.lisp
msgid ""
"When True runs lisp with its input coming from standard-input.\n"
"   If an error is detected returns error code 1, otherwise 0."
msgstr ""

#: target:code/commandline.lisp
msgid ""
"Accepts the name of a switch as a string and returns the value of the\n"
"   switch.  If no value was specified, then any following words are "
"returned.\n"
"   If there are no following words, then t is returned.  If the switch was "
"not\n"
"   specified, then nil is returned."
msgstr ""

#: target:code/commandline.lisp
msgid ""
"When set, invoking switch demons complains about illegal switches that have\n"
"   not been defined with DEFSWITCH."
msgstr ""

#: target:code/commandline.lisp
msgid "~S is an illegal switch"
msgstr ""

#: target:code/commandline.lisp
msgid ""
"Associates function with the switch name in *command-switch-demons*.  Name\n"
"   is a simple-string that does not begin with a hyphen, unless the switch "
"name\n"
"   really does begin with one.  Function is optional, but defining the "
"switch\n"
"   is necessary to keep invoking switch demons from complaining about "
"illegal\n"
"   switches.  This can be inhibited with *complain-about-illegal-switches*."
msgstr ""

#: target:code/commandline.lisp
msgid "a symbol or function"
msgstr ""

#: target:code/env-access.lisp
msgid ""
"Returns information about the symbol VAR in the lexical environment ENV.\n"
"Three values are returned:\n"
"  1) Type or binding of VAR.\n"
"     NIL           No definition or binding\n"
"     :special      VAR is special\n"
"     :lexical      VAR is lexical\n"
"     :symbol-macro VAR refers to a SYMBOL-MACROLET binding\n"
"     :constant     VAR refers to a named constant or VAR is a keyword\n"
"  2) non-NIL if there is a local binding\n"
"  3) An a-list containing information about any declarations that apply."
msgstr ""

#: target:code/env-access.lisp
msgid ""
"Returns information about declarations named by the symbol DECLARATION-"
"NAME.\n"
"Supported DECLARATION-NAMES are\n"
"  1) OPTIMIZE\n"
"     A list whose entries are of the form (QUALITY VALUE) is returned,\n"
"     where QUALITY and VALUE are standard optimization qualities and\n"
"     values.\n"
"  2) EXT:OPTIMIZE-INTERFACE\n"
"     Like OPTIMIZE, but for the EXT:OPTIMIZE-INTERFACE declaration.\n"
"  3) DECLARATION.\n"
"     A list of the declaration names the have been proclaimed as valid."
msgstr ""

#: target:code/env-access.lisp
msgid "Unsupported declaration ~S."
msgstr ""

#: target:code/env-access.lisp
msgid ""
"Process a macro in the same way that DEFMACRO or MACROLET would.\n"
"Three values are returned:\n"
"  1) A lambda-expression that accepts two arguments\n"
"  2) A form\n"
"  3) An environment"
msgstr ""

#: target:code/env-access.lisp
msgid ""
"Returns information about the function name FUNCTION in the lexical "
"environment ENV.\n"
"Three values are returned:\n"
"  1) Type of definition or binding:\n"
"     NIL          No apparent definition\n"
"    :function    FUNCTION refers to a function\n"
"    :macro        FUNCTION refers to a macro\n"
"    :special-form FUNCTION is a special form\n"
"  2) non-NIL if definition is local\n"
"  3) An a-list containing information about the declarations that apply."
msgstr ""

#: target:code/env-access.lisp
msgid ""
"Return a new environment containing information in ENV that is augmented\n"
"by the specified parameters:\n"
"  :VARIABLE     a list of symbols visible as bound variables in the new\n"
"                environemnt\n"
"  :SYMBOL-MACRO a list of symbol macro definitions\n"
"  :FUNCTION     a list of function names that will be visible as local\n"
"                functions\n"
"  :MACRO        a list of local macro definitions\n"
"  :DECLARE      a list of declaration specifiers"
msgstr ""

#: target:code/dfixnum.lisp
msgid "increments dfixnum v by dfixnum i"
msgstr ""

#: target:code/dfixnum.lisp
msgid "dfixnum became too big ~a + ~a"
msgstr ""

#: target:code/dfixnum.lisp
msgid "increments dfixnum v by i (max half fixnum)"
msgstr ""

#: target:code/dfixnum.lisp
msgid "not a half-fixnum: ~a"
msgstr ""

#: target:code/dfixnum.lisp
msgid "decrement dfixnum v by dfixnum i"
msgstr ""

#: target:code/dfixnum.lisp
msgid "dfixnum became negative ~a - ~a (~a/~a)"
msgstr ""

#: target:code/dfixnum.lisp
msgid "decrement dfixnum v by half-fixnum i"
msgstr ""

#: target:code/dfixnum.lisp
msgid ""
"increments dfixnum by an interger which may be bigger than fixnum.\n"
"   May cons"
msgstr ""

#: target:code/dfixnum.lisp
msgid "returns a new dfixnum from number i"
msgstr ""

#: target:code/dfixnum.lisp
msgid "increments a pair of halffixnums by another pair"
msgstr ""

#: target:code/dfixnum.lisp
msgid "decrement dfixnum pair by another pair"
msgstr ""

#: target:code/gc.lisp
#, fuzzy
msgid "Oh no.  The current dynamic space is missing!"
msgstr "현재의 역동적인 공간은 ~D입니다.~%"

#: target:code/gc.lisp
msgid "Dynamic Space Usage:    ~13:D bytes (out of ~4:D MB).~%"
msgstr "동적 공간 사용량 :    ~13:D 바이트 (~4:D 메가바이트의) 아웃.~%"

#: target:code/gc.lisp
msgid "Read-Only Space Usage:  ~13:D bytes (out of ~4:D MB).~%"
msgstr "동적 공간 사용량 :    ~13:D 바이트 (~4:D 메가바이트의) 아웃.~%"

#: target:code/gc.lisp
msgid "Static Space Usage:     ~13:D bytes (out of ~4:D MB).~%"
msgstr "동적 공간 사용량 :    ~13:D 바이트 (~4:D 메가바이트의) 아웃.~%"

#: target:code/gc.lisp
msgid "Control Stack Usage:    ~13:D bytes (out of ~4:D MB).~%"
msgstr "컨트롤 스택 사용:     ~13:D 바이트 (~4:D 메가바이트의) 아웃.~%"

#: target:code/gc.lisp
msgid "Binding Stack Usage:    ~13:D bytes (out of ~4:D MB).~%"
msgstr "바인딩 스택 사용:    ~13:D 바이트 (~4:D 메가바이트의) 아웃.~%"

#: target:code/gc.lisp
msgid "The current dynamic space is ~D.~%"
msgstr "현재의 역동적인 공간은 ~D입니다.~%"

#: target:code/gc.lisp
msgid "Garbage collection is currently ~:[enabled~;DISABLED~].~%"
msgstr "가비지 컬렉션은 현재 ~:[활성화~;비활성화~]되어있습니다.~%"

#: target:code/gc.lisp
msgid ""
"Prints to *STANDARD-OUTPUT* information about the state of internal\n"
"  storage and its management.  The optional argument controls the\n"
"  verbosity of ROOM.  If it is T, ROOM prints out a maximal amount of\n"
"  information.  If it is NIL, ROOM prints out a minimal amount of\n"
"  information.  If it is :DEFAULT or it is not supplied, ROOM prints out\n"
"  an intermediate amount of information.  See also VM:MEMORY-USAGE and\n"
"  VM:INSTANCE-USAGE for finer report control."
msgstr ""
"의 상태에 대한 정보를 인쇄 *STANDARD-OUTPUT* 내부 스토리지 및\n"
"  관리. 선택적 인수 컨트롤 ROOM의 다변. 경우 T입니다 최대한의 금액을\n"
"  인쇄 ROOM 정보. 만약 NIL입니다 최소한의 금액을 인쇄 ROOM 정보. 만약\n"
"  사실이라면 :DEFAULT 또는 제공하지 않으면 인쇄 ROOM 정 보의 중간\n"
"  금액입니다. 또한 VM:MEMORY-USAGE 및보기 양질의 보고서를 제어\n"
"  VM:INSTANCE-USAGE."

#: target:code/gc.lisp
msgid ""
"No way man!  The optional argument to ROOM must be T, NIL, ~\n"
"\t\t or :DEFAULT.~%What do you think you are doing?"
msgstr ""
"말도 안돼 남자! ROOM에 선택적 인수 T, NIL,되어야합니다 ~\n"
"\t\t또는 :DEFAULT.~% 왜 당신이 뭘 생각하는거야?"

#: target:code/gc.lisp
msgid "resetting GC counters"
msgstr ""

#: target:code/gc.lisp
msgid ""
"Returns the number of bytes consed since the first time this function\n"
"  was called.  The first time it is called, it returns zero."
msgstr ""

#: target:code/gc.lisp
msgid ""
"This number specifies the minimum number of bytes of dynamic space\n"
"   that must be consed before the next gc will occur."
msgstr ""
"바이트 처음부터이 기능을 consed의 수를 반환\n"
"  라고했다. 그것이라고 처음으로, 0을 반환합니다."

#: target:code/gc.lisp
msgid ""
"The total CPU time spend doing garbage collection (as reported by\n"
"   GET-INTERNAL-RUN-TIME.)"
msgstr ""
"총 CPU 시간 (로에 의해보고되는 쓰레기를 수거하고 지출\n"
"   GET-INTERNAL-RUN-TIME.)"

#: target:code/gc.lisp
msgid ""
"A list of functions that are called before garbage collection occurs.\n"
"  The functions should take no arguments."
msgstr ""

#: target:code/gc.lisp
msgid ""
"A list of functions that are called after garbage collection occurs.\n"
"  The functions should take no arguments."
msgstr ""

#: target:code/gc.lisp
msgid ""
"Should be bound to a function or NIL.  If it is a function, this\n"
"  function should take one argument, the current amount of dynamic\n"
"  usage.  The function should return NIL if garbage collection should\n"
"  continue and non-NIL if it should be inhibited.  Use with caution."
msgstr ""

#: target:code/gc.lisp
msgid ""
"When non-NIL, causes the functions bound to *GC-NOTIFY-BEFORE* and\n"
"  *GC-NOTIFY-AFTER* to be called before and after a garbage collection\n"
"  occurs respectively.  If :BEEP, causes the default notify functions to "
"beep\n"
"  annoyingly."
msgstr ""

#: target:code/gc.lisp
msgid ""
"~&; [GC threshold exceeded with ~:D bytes in use.  ~\n"
"             Commencing GC.]~%"
msgstr ""
"~&; [GC 문턱은 ~:D 바이트로 사용중인 초과했다.  ~\n"
"             시작 GC.]~%"

#: target:code/gc.lisp
msgid ""
"This function bound to this variable is invoked before GC'ing (unless\n"
"  *GC-VERBOSE* is NIL) with the current amount of dynamic usage (in\n"
"  bytes).  It should notify the user that the system is going to GC."
msgstr ""

#: target:code/gc.lisp
msgid "~&; [GC completed with ~:D bytes retained and ~:D bytes freed.]~%"
msgstr "~&; [유지되는 ~:D의 바이트 및 해방되는 ~:D의 바이트로 완료되는 GC.]~%"

#: target:code/gc.lisp
msgid "~&; [GC will next occur when at least ~:D bytes are in use.]~%"
msgstr "~&; [GC는 다음 적어도 ~:D의 바이트가 사용중인 일 때 일어날 것이다.]~%"

#: target:code/gc.lisp
msgid ""
"The function bound to this variable is invoked after GC'ing (unless\n"
"  *GC-VERBOSE* is NIL) with the amount of dynamic usage (in bytes) now\n"
"  free, the number of bytes freed by the GC, and the new GC trigger\n"
"  threshold.  The function should notify the user that the system has\n"
"  finished GC'ing."
msgstr ""

#: target:code/gc.lisp
msgid ""
"The value of *BYTES-CONSED-BETWEEN-GCS*, ~S, is not an ~\n"
"\t       integer.  Resetting it to ~D."
msgstr ""

#: target:code/gc.lisp
msgid "(FUNCALL ~S~{ ~S~}) lost:~%~A"
msgstr ""

#: target:code/gc.lisp
msgid ""
"Initiates a garbage collection.  The keyword :VERBOSE, which\n"
"   defaults to the value of the variable *GC-VERBOSE* controls whether or\n"
"   not GC statistics are printed. The keyword :GEN defaults to 0, and\n"
"   controls the number of generations to garbage collect."
msgstr ""

#: target:code/gc.lisp
msgid ""
"Return the amount of memory that will be allocated before the next garbage\n"
"   collection is initiated.  This can be set with SETF."
msgstr ""

#: target:code/gc.lisp
msgid "Enables the garbage collector."
msgstr ""

#: target:code/gc.lisp
msgid "Disables the garbage collector."
msgstr ""

#: target:code/gc.lisp
msgid ""
"Return some GC statistics for the specified GENERATION.  The\n"
"  statistics are the number of bytes allocated in this generation; the\n"
"  gc-trigger; the number of bytes consed between GCs; the number of\n"
"  GCs that have occurred; the trigger age; the cumulative number of\n"
"  bytes allocated in this generation; and the average age of this\n"
"  generation.  See the gencgc source code for more info."
msgstr ""

#: target:code/backq.lisp
msgid "How deep we are into backquotes"
msgstr ""

#: target:code/backq.lisp
msgid ",@ after backquote in ~S"
msgstr ""

#: target:code/backq.lisp
msgid ",. after backquote in ~S"
msgstr ""

#: target:code/backq.lisp
msgid "Comma not inside a backquote."
msgstr ""

#: target:code/backq.lisp
msgid ",@ after dot in ~S"
msgstr ""

#: target:code/backq.lisp
msgid ",. after dot in ~S"
msgstr ""

#: target:code/backq.lisp
msgid ""
"Given a lisp form containing the magic functions BACKQ-LIST, BACKQ-LIST*,\n"
"  BACKQ-APPEND, etc. produced by the backquote reader macro, will return a\n"
"  corresponding backquote input form.  In this form, `,' `,@' and `,.' are\n"
"  represented by lists whose cars are BACKQ-COMMA, BACKQ-COMMA-AT, and\n"
"  BACKQ-COMMA-DOT respectively, and whose cadrs are the form after the "
"comma.\n"
"  SPLICING indicates whether a comma-escape return should be modified for\n"
"  splicing with other forms: a value of T or :NCONC meaning that an extra\n"
"  level of parentheses should be added."
msgstr ""

#: target:code/backq.lisp
msgid "### illegal dotted backquote form ###"
msgstr ""

#: target:code/extfmts.lisp
msgid "Attempting unimplemented external-format I/O."
msgstr ""

#: target:code/extfmts.lisp
msgid "Nonsensical argument (~S) to DEFINE-EXTERNAL-FORMAT."
msgstr ""

#: target:code/extfmts.lisp
msgid "Bad entry in external-format aliases file: ~S => ~S."
msgstr ""

#: target:code/extfmts.lisp
msgid "External-format aliases file ends early."
msgstr ""

#: target:code/extfmts.lisp
msgid "External-format aliasing depth exceeded."
msgstr ""

#: target:code/extfmts.lisp
msgid "~S is a Composing-External-Format."
msgstr ""

#: target:code/extfmts.lisp
msgid "~S is not a Composing-External-Format."
msgstr ""

#: target:code/extfmts.lisp
msgid "~S is not a valid external format name."
msgstr ""

#: target:code/extfmts.lisp
msgid "External format ~S not found."
msgstr ""

#: target:code/extfmts.lisp
msgid "Attempting I/O through void external-format."
msgstr ""

#: target:code/extfmts.lisp
msgid ""
"Convert String to octets using the specified External-format.  The\n"
"   string is bounded by Start (defaulting to 0) and End (defaulting to\n"
"   the end of the string.  If Buffer is given, the octets are stored\n"
"   there.  If not, a new buffer is created."
msgstr ""

#: target:code/extfmts.lisp
msgid ""
"Octets-to-string converts an array of octets in Octets to a string\n"
"  according to the specified External-format.  The array of octets is\n"
"  bounded by Start (defaulting ot 0) and End (defaulting to the end of\n"
"  the array.  If String is not given, a new string is created.  If\n"
"  String is given, the converted octets are stored in String, starting\n"
"  at S-Start (defaulting to the 0) and ending at S-End (defaulting to\n"
"  the length of String).  If the string is not large enough to hold\n"
"  all of characters, then some octets will not be converted.  A State\n"
"  may also be specified; this is used as the state of the external\n"
"  format.\n"
"\n"
"  Four values are returned: the string, the number of characters read,\n"
"  the number of octets actually consumed and the new state of the\n"
"  external format."
msgstr ""

#: target:code/extfmts.lisp
msgid ""
"Encode the given String using External-Format and return a new\n"
"  string.  The characters of the new string are the octets of the\n"
"  encoded result, with each octet converted to a character via\n"
"  code-char.  This is the inverse to String-Decode"
msgstr ""

#: target:code/extfmts.lisp
msgid ""
"Decode String using the given External-Format and return the new\n"
"  string.  The input string is treated as if it were an array of\n"
"  octets, where the char-code of each character is the octet.  This is\n"
"  the inverse of String-Encode."
msgstr ""

#: target:code/extfmts.lisp
msgid ""
"Change the external format of the standard streams to Terminal.\n"
"  The standard streams are sys::*stdin*, sys::*stdout*, and\n"
"  sys::*stderr*, which are normally the input and/or output streams\n"
"  for *standard-input* and *standard-output*.  Also sets sys::*tty*\n"
"  (normally *terminal-io* to the given external format.  If the\n"
"  optional argument Filenames is gvien, then the filename encoding is\n"
"  set to the specified format."
msgstr ""

#: target:code/extfmts.lisp
msgid "Can't find external-format ~S."
msgstr ""

#: target:code/extfmts.lisp
msgid "Change it anyway."
msgstr ""

#: target:code/extfmts.lisp
msgid "The external-format for encoding filenames is already set."
msgstr ""

#: target:code/filesys.lisp
msgid ""
"Remove any occurrences of \\ from the string because we've already\n"
"   checked for whatever may have been backslashed."
msgstr ""

#: target:code/filesys.lisp
msgid "Backslash in bad place."
msgstr ""

#: target:code/filesys.lisp
msgid ""
"If non-NIL, Unix shell-style wildcards are ignored when parsing\n"
"  pathname namestrings.  They are also ignored when computing\n"
"  namestrings for pathname objects.  Thus, *, ?, etc. are not\n"
"  wildcards when parsing a namestring, and are not escaped when\n"
"  printing pathnames."
msgstr ""

#: target:code/filesys.lisp
msgid "``['' with no corresponding ``]''"
msgstr ""

#: target:code/filesys.lisp
msgid "~A already names a logical host"
msgstr ""

#: target:code/filesys.lisp
msgid "Invalid pattern piece: ~S"
msgstr ""

#: target:code/filesys.lisp
msgid ":BACK cannot be represented in namestrings."
msgstr ""

#: target:code/filesys.lisp
msgid "Invalid directory component: ~S"
msgstr ""

#: target:code/filesys.lisp
msgid "Cannot specify a directory separator in a pathname name: ~S"
msgstr ""

#: target:code/filesys.lisp
msgid "Cannot specify a dot in a pathname name without a pathname type: ~S"
msgstr ""

#: target:code/filesys.lisp
msgid "Invalid value for a pathname name: ~S"
msgstr ""

#: target:code/filesys.lisp
msgid "Cannot specify the type without a file: ~S"
msgstr ""

#: target:code/filesys.lisp
msgid "Cannot specify a directory separator in a pathname type: ~S"
msgstr ""

#: target:code/filesys.lisp
msgid "Cannot specify a dot in a pathname type: ~S"
msgstr ""

#: target:code/filesys.lisp
msgid "Cannot specify a version without a file: ~S"
msgstr ""

#: target:code/filesys.lisp
msgid "~S cannot be represented relative to ~S"
msgstr ""

#: target:code/filesys.lisp
msgid "Cannot supply a type without a name:~%  ~S"
msgstr ""

#: target:code/filesys.lisp
msgid ""
"Convert PATHNAME into a string that can be used with UNIX system calls.\n"
"   Search-lists and wild-cards are expanded. If optional argument\n"
"   FOR-INPUT is true and PATHNAME doesn't exist, NIL is returned.\n"
"   If optional argument EXECUTABLE-ONLY is true, NIL is returned\n"
"   unless an executable version of PATHNAME exists."
msgstr ""

#: target:code/filesys.lisp
msgid "~S is ambiguous:~{~%  ~A~}"
msgstr ""

#: target:code/filesys.lisp
msgid ""
"Return the pathname for the actual file described by the pathname\n"
"  An error of type file-error is signalled if no such file exists,\n"
"  or the pathname is wild."
msgstr ""

#: target:code/filesys.lisp
msgid "Bad place for a wild pathname."
msgstr ""

#: target:code/filesys.lisp
msgid "The file ~S does not exist."
msgstr ""

#: target:code/filesys.lisp
msgid ""
"Return a pathname which is the truename of the file if it exists, NIL\n"
"  otherwise. An error of type file-error is signalled if pathname is wild."
msgstr ""

#: target:code/filesys.lisp
msgid ""
"Rename File to have the specified New-Name.  If file is a stream open to a\n"
"  file, then the associated file is renamed."
msgstr ""

#: target:code/filesys.lisp
msgid "~S can't be created."
msgstr ""

#: target:code/filesys.lisp
msgid "Failed to rename ~A to ~A: ~A"
msgstr ""

#: target:code/filesys.lisp
msgid "Delete the specified file."
msgstr ""

#: target:code/filesys.lisp
msgid "~S doesn't exist."
msgstr ""

#: target:code/filesys.lisp
msgid "Could not delete ~A: ~A."
msgstr ""

#: target:code/filesys.lisp
msgid ""
"Delete old versions of files matching the given Pathname,\n"
"optionally keeping some of the most recent old versions."
msgstr ""

#: target:code/filesys.lisp
msgid ""
"Returns the home directory of the logged in user as a pathname.\n"
"  This is obtained from the logical name \"home:\"."
msgstr ""

#: target:code/filesys.lisp
msgid ""
"Return file's creation date, or NIL if it doesn't exist.\n"
" An error of type file-error is signalled if file is a wild pathname"
msgstr ""

#: target:code/filesys.lisp
msgid ""
"Returns the file author as a string, or nil if the author cannot be\n"
" determined.  Signals an error of type file-error if file doesn't exist,\n"
" or file is a wild pathname."
msgstr ""

#: target:code/filesys.lisp
msgid ""
"Returns a list of pathnames, one for each file that matches the given\n"
"   pathname.  Supplying :ALL as nil causes this to ignore Unix dot files.  "
"This\n"
"   never includes Unix dot and dot-dot in the result.  If :TRUENAMEP is "
"NIL,\n"
"   then symbolic links in the result are not expanded, which is not the\n"
"   default because TRUENAME does follow links and the result pathnames are\n"
"   defined to be the TRUENAME of the pathname (the truename of a link may "
"well\n"
"   be in another directory).  If FOLLOW-LINKS is NIL then symbolic links "
"are\n"
"   not followed."
msgstr ""

#: target:code/filesys.lisp
msgid ""
"Like Directory, but prints a terse, multi-column directory listing\n"
"   instead of returning a list of pathnames.  When :all is supplied and\n"
"   non-nil, then Unix dot files are included too (as ls -a).  When :verbose\n"
"   is supplied and non-nil, then a long listing of miscellaneous\n"
"   information is output one file per line."
msgstr ""

#: target:code/filesys.lisp
msgid "Directory of ~A:~%"
msgstr ""

#: target:code/filesys.lisp
msgid "Couldn't stat ~A -- ~A.~%"
msgstr ""

#: target:code/filesys.lisp
msgid ""
"Return a list of all files which are possible completions of Pathname.\n"
"   We look in the directory specified by Defaults as well as looking down\n"
"   the search list."
msgstr ""

#: target:code/filesys.lisp
msgid ""
"File-writable accepts a pathname and returns T if the current\n"
"  process can write it, and NIL otherwise."
msgstr ""

#: target:code/filesys.lisp
msgid ""
"Returns the pathname for the default directory.  This is the place where\n"
"  a file will be written if no directory is specified.  This may be changed\n"
"  with setf."
msgstr ""

#: target:code/filesys.lisp
msgid ""
"Tests whether the directories containing the specified file\n"
"  actually exist, and attempts to create them if they do not.\n"
"  Portable programs should avoid using the :MODE keyword argument."
msgstr ""

#: target:code/filesys.lisp
msgid "~&Creating directory: ~A~%"
msgstr ""

#: target:code/filesys.lisp
msgid "Can't create directory ~A."
msgstr ""

#: target:code/foreign-linkage.lisp
msgid "~A is not defined as a foreign symbol"
msgstr ""

#: target:code/eval.lisp
msgid ""
"Keywords that you can put in a lambda-list, supposing you should want\n"
"  to do such a thing."
msgstr ""

#: target:code/eval.lisp
msgid ""
"The exclusive upper bound on the number of arguments which may be passed\n"
"  to a function, including rest args."
msgstr ""

#: target:code/eval.lisp
msgid ""
"The exclusive upper bound on the number of parameters which may be specifed\n"
"  in a given lambda list.  This is actually the limit on required and "
"optional\n"
"  parameters.  With &key and &aux you can get more."
msgstr ""

#: target:code/eval.lisp
msgid ""
"The exclusive upper bound on the number of multiple-values that you can\n"
"  have."
msgstr ""

#: target:code/eval.lisp
msgid ""
"This variable controls whether assignments to unknown variables at top-"
"level\n"
"   (or in any other call to EVAL of SETQ) will implicitly declare the "
"variable\n"
"   SPECIAL.  These values are meaningful:\n"
"     :WARN  -- Print a warning, but declare the variable special (the "
"default.)\n"
"      T     -- Quietly declare the variable special.\n"
"      NIL   -- Never declare the variable, giving warnings on each use."
msgstr ""

#: target:code/eval.lisp
msgid ""
"Evaluates its single arg in a null lexical environment, returns the\n"
"  result or results."
msgstr ""

#: target:code/eval.lisp
msgid "Wrong number of args to FUNCTION:~% ~S."
msgstr ""

#: target:code/eval.lisp
msgid "~S is a macro."
msgstr ""

#: target:code/eval.lisp
msgid "~S is a special operator."
msgstr ""

#: target:code/eval.lisp
msgid "Wrong number of args to QUOTE:~% ~S."
msgstr ""

#: target:code/eval.lisp
msgid "Odd number of args to SETQ:~% ~S."
msgstr ""

#: target:code/eval.lisp
msgid "Declaring ~S special."
msgstr ""

#: target:code/eval.lisp
msgid "Bad Eval-When situation list: ~S."
msgstr ""

#: target:code/eval.lisp
msgid ""
"Attempt to evaluation a complex expression:~%     ~S~@\n"
"\t  This expression must be compiled, but the compiler is not loaded."
msgstr ""

#: target:code/eval.lisp
msgid ""
"EVAL called on #'(lambda (x) ...) when the compiler isn't loaded:~\n"
"\t  ~%     ~S~%"
msgstr ""

#: target:code/eval.lisp
msgid ""
"Given a function, return three values:\n"
"   1] A lambda expression that could be used to define the function, or NIL "
"if\n"
"      the definition isn't available.\n"
"   2] NIL if the function was definitely defined in a null lexical "
"environment,\n"
"      and T otherwise.\n"
"   3] Some object that \"names\" the function.  Although this is allowed to "
"be\n"
"      any object, CMU CL always returns a valid function name or a string."
msgstr ""

#: target:code/eval.lisp
msgid "If the symbol globally names a special form, returns T, otherwise NIL."
msgstr ""

#: target:code/eval.lisp
msgid ""
"The value of this variable must be a function that can take three\n"
"  arguments, a macro expander function, the macro form to be expanded,\n"
"  and the lexical environment to expand in.  The function should\n"
"  return the expanded form.  This function is called by MACROEXPAND-1\n"
"  whenever a runtime expansion is needed.  Initially this is set to\n"
"  FUNCALL."
msgstr ""

#: target:code/eval.lisp
msgid ""
"Invoke *MACROEXPAND-HOOK* on FUN, FORM, and ENV after coercing it to\n"
"   a function."
msgstr ""

#: target:code/eval.lisp
msgid ""
"If SYMBOL names a macro in ENV, returns the expansion function,\n"
"   else returns NIL.  If ENV is unspecified or NIL, use the global\n"
"   environment only."
msgstr ""

#: target:code/eval.lisp
msgid "~S names a special form."
msgstr ""

#: target:code/eval.lisp
msgid "Cannot funcall macro functions."
msgstr ""

#: target:code/eval.lisp
msgid ""
"If form is a macro (or symbol macro), expands it once.  Returns two values,\n"
"   the expanded form and a T-or-NIL flag indicating whether the form was, "
"in\n"
"   fact, a macro.  Env is the lexical environment to expand in, which "
"defaults\n"
"   to the null environment."
msgstr ""

#: target:code/eval.lisp
msgid ""
"Repetitively call MACROEXPAND-1 until the form can no longer be expanded.\n"
"   Returns the final resultant form, and T if it was expanded.  ENV is the\n"
"   lexical environment to expand in, or NIL (the default) for the null\n"
"   environment."
msgstr ""

#: target:code/eval.lisp
msgid ""
"If NAME names a compiler-macro, returns the expansion function,\n"
"   else returns NIL.  Note: if the name is shadowed in ENV by a local\n"
"   definition, or declared NOTINLINE, NIL is returned.  Can be\n"
"   set with SETF."
msgstr ""

#: target:code/eval.lisp
msgid ""
"If FORM is a function call for which a compiler-macro has been defined,\n"
"   invoke the expander function using *macroexpand-hook* and return the\n"
"   results and T.  Otherwise, return the original form and NIL."
msgstr ""

#: target:code/eval.lisp
msgid ""
"Repetitively call COMPILER-MACROEXPAND-1 until the form can no longer be\n"
"   expanded.  ENV is the lexical environment to expand in, or NIL (the\n"
"   default) for the null environment."
msgstr ""

#: target:code/eval.lisp
msgid ""
"True of any Lisp object that has a constant value: types that eval to\n"
"  themselves, keywords, constants, and list whose car is QUOTE."
msgstr ""

#: target:code/eval.lisp
msgid ""
"Applies FUNCTION to a list of arguments produced by evaluating ARGS in\n"
"  the manner of LIST*.  That is, a list is made of the values of all but "
"the\n"
"  last argument, appended to the value of the last argument, which must be "
"a\n"
"  list."
msgstr ""

#: target:code/eval.lisp
msgid "Calls Function with the given Arguments."
msgstr ""

#: target:code/eval.lisp
msgid "Returns all of its arguments, in order, as values."
msgstr ""

#: target:code/eval.lisp
msgid "Returns all of the elements of List, in order, as values."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"All debug-conditions inherit from this type.  These are serious conditions\n"
"    that must be handled, but they are not programmer errors."
msgstr ""

#: target:code/debug-int.lisp
msgid "There is absolutely no debugging information available."
msgstr ""

#: target:code/debug-int.lisp
msgid "No debugging information available."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"The system could not return values from a frame with debug-function since\n"
"    it lacked information about returning values."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"~&Cannot return values from ~:[frame~;~:*~S~] since ~\n"
"\t\t\tthe debug information lacks details about returning ~\n"
"\t\t\tvalues here."
msgstr ""

#: target:code/debug-int.lisp
msgid "The debug-function has no debug-block information."
msgstr ""

#: target:code/debug-int.lisp
msgid "~&~S has no debug-block information."
msgstr ""

#: target:code/debug-int.lisp
msgid "The debug-function has no debug-variable information."
msgstr ""

#: target:code/debug-int.lisp
msgid "~&~S has no debug-variable information."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"The debug-function has no lambda-list since argument debug-variables are\n"
"    unavailable."
msgstr ""

#: target:code/debug-int.lisp
msgid "~&~S has no lambda-list information available."
msgstr ""

#: target:code/debug-int.lisp
msgid "~&~S has :invalid or :unknown value in ~S."
msgstr ""

#: target:code/debug-int.lisp
msgid "~&~S names more than one valid variable in ~S."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"All programmer errors from using the interface for building debugging\n"
"    tools inherit from this type."
msgstr ""

#: target:code/debug-int.lisp
msgid "~&Unhandled debug-condition:~%~A"
msgstr ""

#: target:code/debug-int.lisp
msgid "~&Invalid use of an unknown code-location -- ~S."
msgstr ""

#: target:code/debug-int.lisp
msgid "~&~S not in ~S."
msgstr ""

#: target:code/debug-int.lisp
msgid "Invalid control stack pointer."
msgstr ""

#: target:code/debug-int.lisp
msgid "~&Form was preprocessed for ~S,~% but called on ~S:~%  ~S"
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns the name of the debug-variable.  The name is the name of the symbol\n"
"   used as an identifier when writing the code."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns the package name of the debug-variable.  This is the package name "
"of\n"
"   the symbol used as an identifier when writing the code."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns the integer that makes debug-variable's name and package name "
"unique\n"
"   with respect to other debug-variable's in the same function."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns the frame immediately above frame on the stack.  When frame is\n"
"   the top of the stack, this returns nil."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns the debug-function for the function whose call frame represents."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns the code-location where the frame's debug-function will continue\n"
"   running when program execution returns to this frame.  If someone\n"
"   interrupted this frame, the result could be an unknown code-location."
msgstr ""

#: target:code/debug-int.lisp
msgid "#<Compiled-Frame ~S~:[~;, interrupted~]>"
msgstr ""

#: target:code/debug-int.lisp
msgid "#<~A-Debug-Function ~S>"
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns the list of possible code-locations where execution may continue\n"
"   when the basic-block represented by debug-block completes its execution."
msgstr ""

#: target:code/debug-int.lisp
msgid "Returns whether debug-block represents elsewhere code."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns the breakpoint's function the system calls when execution "
"encounters\n"
"   the breakpoint, and it is active.  This is SETF'able."
msgstr ""

#: target:code/debug-int.lisp
msgid "Returns the breakpoint's what specification."
msgstr ""

#: target:code/debug-int.lisp
msgid "Returns the breakpoint's kind specification."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns the debug-function representing information about the function\n"
"   corresponding to the code-location."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns the number of top-level forms processed by the compiler before\n"
"   compiling this source.  If this source is uncompiled, this is zero.  "
"This\n"
"   may be zero even if the source is compiled since the first form in the "
"first\n"
"   file compiled in one compilation, for example, must have a root number "
"of\n"
"   zero -- the compiler saw no other top-level forms before it."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns an indication of the type of source.  The following are the "
"possible\n"
"   values:\n"
"      :file    from a file (obtained by COMPILE-FILE if compiled).\n"
"      :lisp    from Lisp (obtained by COMPILE if compiled).\n"
"      :stream  from a non-file stream."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns the actual source in some sense represented by debug-source, which\n"
"   is related to DEBUG-SOURCE-FROM:\n"
"      :file    the pathname of the file.\n"
"      :lisp    a lambda-expression.\n"
"      :stream  some descriptive string that's otherwise useless."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns the universal time someone created the source.  This may be nil if\n"
"   it is unavailable."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns the time someone compiled the source.  This is nil if the source\n"
"   is uncompiled."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"This function returns the file position of each top-level form as an array\n"
"   if debug-source is from a :file.  If DEBUG-SOURCE-FROM is :lisp or :"
"stream,\n"
"   this returns nil."
msgstr ""

#: target:code/debug-int.lisp
msgid "Returns whether object is a debug-source."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns the top frame of the control stack as it was before calling this\n"
"   function."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Flush all of the frames above FRAME, and renumber all the frames below\n"
"   FRAME."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns the frame immediately below frame on the stack.  When frame is\n"
"   the bottom of the stack, this returns nil."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"When set, the debugger foregoes making interpreted-frames, so you can\n"
"   debug the functions that manifest the interpreter."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Zero or more than one ~A variable in ~\n"
"\t\t\t   EVAL::INTERNAL-APPLY-LOOP?"
msgstr ""

#: target:code/debug-int.lisp
msgid "Return a string describing the foreign function near ADDRESS"
msgstr ""

#: target:code/debug-int.lisp
msgid "Foreign function call land"
msgstr ""

#: target:code/debug-int.lisp
msgid "Return t if COMPONENT contains code from assembly routines."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Return the name of the assembly routine at offset PC in COMPONENT.\n"
"The result is a symbol or nil if the routine cannot be found."
msgstr ""

#: target:code/debug-int.lisp
msgid "find the PC"
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns an a-list mapping catch tags to code-locations.  These are\n"
"   code-locations at which execution would continue with frame as the top\n"
"   frame if someone threw to the corresponding tag."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Executes the forms in a context with block-var bound to each debug-block in\n"
"   debug-function successively.  Result is an optional form to execute for\n"
"   return values, and DO-DEBUG-FUNCTION-BLOCKS returns nil if there is no\n"
"   result form.  This signals a no-debug-blocks condition when the\n"
"   debug-function lacks debug-block information."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Executes body in a context with var bound to each debug-variable in\n"
"   debug-function.  This returns the value of executing result (defaults to\n"
"   nil).  This may iterate over only some of debug-function's variables or "
"none\n"
"   depending on debug policy; for example, possibly the compilation only\n"
"   preserved argument information."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns the Common Lisp function associated with the debug-function.  This\n"
"   returns nil if the function is unavailable or is non-existent as a user\n"
"   callable function object."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns the name of the function represented by debug-function.  This may\n"
"   be a string or a cons; do not assume it is a symbol."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns a debug-function that represents debug information for function."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns the kind of the function which is one of :optional, :external,\n"
"   :top-level, :cleanup, nil."
msgstr ""

#: target:code/debug-int.lisp
msgid "Returns whether there is any variable information for debug-function."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns a list of debug-variables in debug-function having the same name\n"
"   and package as symbol.  If symbol is uninterned, then this returns a list "
"of\n"
"   debug-variables without package names and with the same name as symbol.  "
"The\n"
"   result of this function is limited to the availability of variable\n"
"   information in debug-function; for example, possibly debug-function only\n"
"   knows about its arguments."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns a list of debug-variables in debug-function whose names contain\n"
"    name-prefix-string as an intial substring.  The result of this function "
"is\n"
"    limited to the availability of variable information in debug-function; "
"for\n"
"    example, possibly debug-function only knows about its arguments."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns a list representing the lambda-list for debug-function.  The list\n"
"   has the following structure:\n"
"      (required-var1 required-var2\n"
"       ...\n"
"       (:optional var3 suppliedp-var4)\n"
"       (:optional var5)\n"
"       ...\n"
"       (:rest var6) (:rest var7)\n"
"       ...\n"
"       (:keyword keyword-symbol var8 suppliedp-var9)\n"
"       (:keyword keyword-symbol var10)\n"
"       ...\n"
"      )\n"
"   Each VARi is a debug-variable; however it may be the symbol :deleted it\n"
"   is unreferenced in debug-function.  This signals a lambda-list-"
"unavaliable\n"
"   condition when there is no argument list information."
msgstr ""

#: target:code/debug-int.lisp
msgid "Malformed arguments description."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns whether basic-code-location is unknown.  It returns nil when the\n"
"   code-location is known."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns the debug-block containing code-location if it is available.  Some\n"
"   debug policies inhibit debug-block information, and if none is "
"available,\n"
"   then this signals a no-debug-blocks condition."
msgstr ""

#: target:code/debug-int.lisp
msgid "Returns the code-location's debug-source."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns the number of top-level forms before the one containing\n"
"   code-location as seen by the compiler in some compilation unit.  A\n"
"   compilation unit is not necessarily a single file, see the section on\n"
"   debug-sources."
msgstr ""

#: target:code/debug-int.lisp
msgid "Unknown code location?  It should be known."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns the number of the form corresponding to code-location.  The form\n"
"   number is derived by a walking the subforms of a top-level form in\n"
"   depth-first order."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Return the kind of CODE-LOCATION, one of:\n"
"     :interpreted, :unknown-return, :known-return, :internal-error,\n"
"     :non-local-exit, :block-start, :call-site, :single-value-return,\n"
"     :non-local-entry"
msgstr ""

#: target:code/debug-int.lisp
msgid "Returns whether obj1 and obj2 are the same place in the code."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Executes forms in a context with code-var bound to each code-location in\n"
"   debug-block.  This returns the value of executing result (defaults to "
"nil)."
msgstr ""

#: target:code/debug-int.lisp
msgid "??? Can't get name of debug-block's function."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns the symbol from interning DEBUG-VARIABLE-NAME in the package named\n"
"   by DEBUG-VARIABLE-PACKAGE."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns the value stored for debug-variable in frame.  If the value is not\n"
"   :valid, then this signals an invalid-value error."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns the value stored for debug-variable in frame.  The value may be\n"
"   invalid.  This is SETF'able."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Returns three values reflecting the validity of debug-variable's value\n"
"   at basic-code-location:\n"
"      :valid    The value is known to be available.\n"
"      :invalid  The value is known to be unavailable.\n"
"      :unknown  The value's availability is unknown."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"This returns a table mapping form numbers to source-paths.  A source-path\n"
"   indicates a descent into the top-level-form form, going directly to the\n"
"   subform corressponding to the form number."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Form is a top-level form, and path is a source-path into it.  This returns\n"
"   the form indicated by the source-path.  Context is the number of "
"enclosing\n"
"   forms to return instead of directly returning the source-path form.  "
"When\n"
"   context is non-zero, the form returned contains a marker, #:"
"****HERE****,\n"
"   immediately before the form indicated by path."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Return a function of one argument that evaluates form in the lexical\n"
"   context of the basic-code-location loc.  PREPROCESS-FOR-EVAL signals a\n"
"   no-debug-variables condition when the loc's debug-function has no\n"
"   debug-variable information available.  The returned function takes the "
"frame\n"
"   to get values from as its argument, and it returns the values of form.\n"
"   The returned function signals the following conditions: invalid-value,\n"
"   ambiguous-variable-name, and frame-function-mismatch"
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Evaluate Form in the lexical context of Frame's current code location,\n"
"   returning the results of the evaluation."
msgstr ""

#: target:code/debug-int.lisp
msgid "Find and return the debug catch tag for a given frame, if it exists."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Evaluate Form in the lexical context of Frame's current code location,\n"
"   returning from the current frame the results of the evaluation."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"This creates and returns a breakpoint.  When program execution encounters\n"
"   the breakpoint, the system calls hook-function.  Hook-function takes the\n"
"   current frame for the function in which the program is running and the\n"
"   breakpoint object.\n"
"      What and kind determine where in a function the system invokes\n"
"   hook-function.  What is either a code-location or a debug-function.  Kind "
"is\n"
"   one of :code-location, :function-start, or :function-end.  Since the "
"starts\n"
"   and ends of functions may not have code-locations representing them,\n"
"   designate these places by supplying what as a debug-function and kind\n"
"   indicating the :function-start or :function-end.  When what is a\n"
"   debug-function and kind is :function-end, then hook-function must take "
"two\n"
"   additional arguments, a list of values returned by the function and a\n"
"   function-end-cookie.\n"
"      Info is information supplied by and used by the user.\n"
"      Function-end-cookie is a function.  To implement :function-end "
"breakpoints,\n"
"   the system uses starter breakpoints to establish the :function-end "
"breakpoint\n"
"   for each invocation of the function.  Upon each entry, the system creates "
"a\n"
"   unique cookie to identify the invocation, and when the user supplies a\n"
"   function for this argument, the system invokes it on the frame and the\n"
"   cookie.  The system later invokes the :function-end breakpoint hook on "
"the\n"
"   same cookie.  The user may save the cookie for comparison in the hook\n"
"   function.\n"
"      This signals an error if what is an unknown code-location."
msgstr ""

#: target:code/debug-int.lisp
msgid "Cannot make a breakpoint at an unknown code location -- ~S."
msgstr ""

#: target:code/debug-int.lisp
msgid "Breakpoints in interpreted code are currently unsupported."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
":FUNCTION-END breakpoints are currently unsupported ~\n"
"\t\t       for the known return convention."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
":function-end breakpoints are currently unsupported ~\n"
"\t     for interpreted-debug-functions."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"This takes a function-end-cookie and a frame, and it returns whether the\n"
"   cookie is still valid.  A cookie becomes invalid when the frame that\n"
"   established the cookie has exited.  Sometimes cookie holders are unaware\n"
"   of cookie invalidation because their :function-end breakpoint hooks "
"didn't\n"
"   run due to THROW'ing.  This takes a frame as an efficiency hack since "
"the\n"
"   user probably has a frame object in hand when using this routine, and it\n"
"   saves repeated parsing of the stack and consing when asking whether a\n"
"   series of cookies is valid."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"This causes the system to invoke the breakpoint's hook-function until the\n"
"   next call to DEACTIVATE-BREAKPOINT or DELETE-BREAKPOINT.  The system "
"invokes\n"
"   breakpoint hook functions in the opposite order that you activate them."
msgstr ""

#: target:code/debug-int.lisp
msgid "Cannot activate a deleted breakpoint -- ~S."
msgstr ""

#: target:code/debug-int.lisp
msgid "I don't know how you made this, but they're unsupported -- ~S"
msgstr ""

#: target:code/debug-int.lisp
msgid "This stops the system from invoking the breakpoint's hook-function."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"This returns the user maintained info associated with breakpoint.  This\n"
"   is SETF'able."
msgstr ""

#: target:code/debug-int.lisp
msgid "This returns whether breakpoint is currently active."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"This frees system storage and removes computational overhead associated "
"with\n"
"   breakpoint.  After calling this, breakpoint is completely impotent and "
"can\n"
"   never become active again."
msgstr ""

#: target:code/debug-int.lisp
msgid "Unknown breakpoint in ~S at offset ~S."
msgstr ""

#: target:code/debug-int.lisp
msgid "Breakpoint that nobody wants?"
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Make a bogus LRA object that signals a breakpoint trap when returned to.  "
"If\n"
"   the breakpoint trap handler returns, REAL-LRA is returned to.  Three "
"values\n"
"   are returned: the bogus LRA object, the code component it is part of, "
"and\n"
"   the PC offset for the trap instruction."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"The editor calls this remotely in the slave to set breakpoints.  Package is\n"
"   the string name of a package or nil, and name-str is a string "
"representing a\n"
"   function name (for example, \"foo\" or \"(setf foo)\").  After finding\n"
"   package, this READs name-str with *package* bound appropriately.  Path "
"is\n"
"   either a modified source-path or a symbol (:function-start or\n"
"   :function-end).  If it is a modified source-path, it has no top-level-"
"form\n"
"   offset or form-number component, and it is in descent order from the root "
"of\n"
"   the top-level form."
msgstr ""

#: target:code/debug-int.lisp
msgid "Editor installed breakpoint."
msgstr ""

#: target:code/debug-int.lisp
msgid "We don't currently support breakpoints in interpreted code."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"~%Cannot set breakpoints for editor when source file no ~\n"
"\t\t    longer exists:~%  ~A."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"~%While setting a breakpoint for the editor, noticed ~\n"
"\t\t\tsource file has been modified since compilation:~%  ~A~@\n"
"\t\t\tUsing form offset instead of character position.~%"
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"Cannot set breakpoints for editor when ~\n"
"\t\t\t\t   there is no start positions map."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"The editor calls this in the slave with a remote-object representing a\n"
"   code-location to set a breakpoint."
msgstr ""

#: target:code/debug-int.lisp
msgid "The editor calls this remotely in the slave to delete a breakpoint."
msgstr ""

#: target:code/debug-int.lisp
msgid ""
"This returns a code-location before the body of a function and after all\n"
"   the arguments are in place.  If this cannot determine that location due "
"to\n"
"   a lack of debug information, it returns nil."
msgstr ""

#: target:code/debug-int.lisp
msgid "~S code location at ~D"
msgstr ""

#: target:code/profile.lisp
msgid "dfixnum became negative ~a/~a - ~a/~a(~a/~a)"
msgstr ""

#: target:code/profile.lisp
msgid "dfixnum became too big ~a/~a + ~a/~a"
msgstr ""

#: target:code/final.lisp
msgid ""
"Arrange for FUNCTION to be called when there are no more references to\n"
"   OBJECT.  FUNCTION takes no arguments."
msgstr ""

#: target:code/final.lisp
msgid "Cancel any finalization registers for OBJECT."
msgstr ""

#: target:code/describe.lisp
msgid "Depth of recursive descriptions allowed."
msgstr "허용되는 재귀적인 묘사의 깊이."

#: target:code/describe.lisp
msgid ""
"If non-nil, descriptions may provide interpretations of information and\n"
"  pointers to additional information.  Normally nil."
msgstr ""

#: target:code/describe.lisp
msgid ""
"*print-level* gets bound to this inside describe.  If null, use\n"
"  *print-level*"
msgstr ""

#: target:code/describe.lisp
msgid ""
"*print-length* gets bound to this inside describe.  If null, use\n"
"  *print-length*."
msgstr ""

#: target:code/describe.lisp
msgid "Number of spaces that sets off each line of a recursive description."
msgstr ""

#: target:code/describe.lisp
msgid "Used to tell whether we are doing a recursive describe."
msgstr ""

#: target:code/describe.lisp
msgid "Used to implement recursive description cutoff.  Don't touch."
msgstr ""

#: target:code/describe.lisp
msgid "An output stream used by Describe for indenting and stuff."
msgstr ""

#: target:code/describe.lisp
msgid ""
"List of all objects describe within the current top-level call to describe."
msgstr ""

#: target:code/describe.lisp
msgid "The last object passed to describe."
msgstr ""

#: target:code/describe.lisp
msgid "Prints a description of the object X."
msgstr ""

#: target:code/describe.lisp
msgid "*describe-level* should be a nonnegative integer - ~A."
msgstr ""

#: target:code/describe.lisp
msgid "~&~S is a ~S."
msgstr ""

#: target:code/describe.lisp
msgid "~&Its code is #x~4,'0x."
msgstr ""

#: target:code/describe.lisp
msgid "~&Its name is ~A."
msgstr ""

#: target:code/describe.lisp
msgid "~&It is a ~:[high (leading)~;low (trailing)~] surrogate character."
msgstr ""

#: target:code/describe.lisp
msgid "~&~S is a ~(~A~) of type ~A."
msgstr ""

#: target:code/describe.lisp
msgid "~&~S is a ~:[~;displaced ~]vector of length ~D."
msgstr ""

#: target:code/describe.lisp
msgid "~&It has a fill pointer, currently ~d"
msgstr ""

#: target:code/describe.lisp
msgid "~&It has no fill pointer."
msgstr ""

#: target:code/describe.lisp
msgid "~&~S is ~:[an~;a displaced~] array of rank ~A"
msgstr ""

#: target:code/describe.lisp
msgid "~%Its dimensions are ~S."
msgstr ""

#: target:code/describe.lisp
msgid "~&Its element type is specialized to ~S."
msgstr ""

#: target:code/describe.lisp
msgid "~&It is adjustable."
msgstr ""

#: target:code/describe.lisp
msgid "~&It is static."
msgstr ""

#: target:code/describe.lisp
msgid "~&It is a prime number."
msgstr ""

#: target:code/describe.lisp
msgid "~&It is a composite number."
msgstr ""

#: target:code/describe.lisp
msgid "~&Its components are ~S and ~S."
msgstr ""

#: target:code/describe.lisp
msgid "~&~S is an ~A hash table."
msgstr ""

#: target:code/describe.lisp
msgid "~&Its size is ~D buckets."
msgstr ""

#: target:code/describe.lisp
msgid "~&Its rehash-size is ~S."
msgstr ""

#: target:code/describe.lisp
msgid "~&Its rehash-threshold is ~S."
msgstr ""

#: target:code/describe.lisp
msgid "~&It currently holds ~d entries."
msgstr ""

#: target:code/describe.lisp
msgid "~&It is weak ~A table."
msgstr ""

#: target:code/describe.lisp
msgid "~&~d symbols total: ~d internal and ~d external."
msgstr ""

#: target:code/describe.lisp
msgid "~&~@(~A documentation:~)~&  ~A"
msgstr ""

#: target:code/describe.lisp
msgid "~&Its ~(~A~) argument types are:~%  ~S"
msgstr ""

#: target:code/describe.lisp
msgid "~&Its result type is:~%  ~S"
msgstr ""

#: target:code/describe.lisp
msgid ""
"~&It is currently declared ~(~A~);~\n"
"\t\t ~:[no~;~] expansion is available."
msgstr ""

#: target:code/describe.lisp
msgid "~&~@(~@[~A ~]arguments:~%~)"
msgstr ""

#: target:code/describe.lisp
msgid "  There are no arguments."
msgstr ""

#: target:code/describe.lisp
msgid "~&Its closure environment is:"
msgstr ""

#: target:code/describe.lisp
msgid "~&Its definition is:~%  ~S"
msgstr ""

#: target:code/describe.lisp
msgid "~&On ~A it was compiled from:"
msgstr ""

#: target:code/describe.lisp
msgid "~&~A~%  Created: "
msgstr ""

#: target:code/describe.lisp
msgid "~&  Comment: ~A"
msgstr ""

#: target:code/describe.lisp
msgid "  There is no argument information available."
msgstr ""

#: target:code/describe.lisp
msgid "Macro-function: ~S"
msgstr ""

#: target:code/describe.lisp
msgid "Function: ~S"
msgstr ""

#: target:code/describe.lisp
msgid "~S is a function."
msgstr ""

#: target:code/describe.lisp
msgid "~&It is an unknown type of function."
msgstr ""

#: target:code/describe.lisp
msgid "~&~A is an ~A symbol in the ~A package."
msgstr ""

#: target:code/describe.lisp
msgid "~&~A is an uninterned symbol."
msgstr ""

#: target:code/describe.lisp
msgid "~&~@<It is an alien at #x~8,'0X of type ~3I~:_~S.~:>~%"
msgstr ""

#: target:code/describe.lisp
msgid "~@<Its current value is ~3I~:_~S.~:>"
msgstr ""

#: target:code/describe.lisp
msgid "~&It is a ~A with expansion: ~S."
msgstr ""

#: target:code/describe.lisp
msgid "~&It is a ~A; its value is ~S."
msgstr ""

#: target:code/describe.lisp
msgid "~&It is a ~A; no current value."
msgstr ""

#: target:code/describe.lisp
msgid "~&Its declared type is ~S."
msgstr ""

#: target:code/describe.lisp
msgid "special variable"
msgstr ""

#: target:code/describe.lisp
msgid "constant"
msgstr ""

#: target:code/describe.lisp
msgid "undefined variable"
msgstr ""

#: target:code/describe.lisp
msgid "symbol macro"
msgstr ""

#: target:code/describe.lisp
msgid "Special form"
msgstr ""

#: target:code/describe.lisp
msgid "Structure"
msgstr ""

#: target:code/describe.lisp
msgid "Type"
msgstr ""

#: target:code/describe.lisp
msgid "Setf macro"
msgstr ""

#: target:code/describe.lisp
msgid "~&Documentation on the ~(~A~):~%~A"
msgstr ""

#: target:code/describe.lisp
msgid "~&It names a class ~A."
msgstr ""

#: target:code/describe.lisp
msgid "~&It names a PCL class ~A."
msgstr ""

#: target:code/describe.lisp
msgid "~&It names a type specifier."
msgstr ""

#: target:code/describe.lisp
msgid "~&Its ~S property is ~S."
msgstr ""

#: target:code/describe.lisp
msgid "~&It is defined in:~&~A"
msgstr ""

#: target:code/format-time.lisp
msgid ""
"Format-Universal-Time formats a string containing the time and date\n"
"   given by universal-time in a common manner.  The destination is any\n"
"   destination which can be accepted by the Format function.  The\n"
"   timezone keyword is an integer specifying hours west of Greenwich.\n"
"   The style keyword can be :short (numeric date), :long (months and\n"
"   weekdays expressed as words), :abbreviated (like :long but words\n"
"   are abbreviated), :rfc1123 (conforming to RFC 1123), :government\n"
"   (of the form \"XX Mon XX XX:XX:XX\"), or :iso8601 (conforming to\n"
"   ISO 8601), which is the recommended way of printing date and time.\n"
"   The keyword date-first, if nil, will print the time first instead of\n"
"   the date (the default).  The print- keywords, if nil, inhibit the\n"
"   printing of the obvious part of the time/date."
msgstr ""

#: target:code/format-time.lisp
msgid "~A: Not a valid format destination."
msgstr ""

#: target:code/format-time.lisp
msgid "~A: Universal-Time should be an integer."
msgstr ""

#: target:code/format-time.lisp
msgid "~A: Timezone should be a rational between -24 and 24."
msgstr ""

#: target:code/format-time.lisp
msgid "~A: Timezone is not a second (1/3600) multiple."
msgstr ""

#: target:code/format-time.lisp
msgid "~A: Unrecognized :style keyword value."
msgstr ""

#: target:code/format-time.lisp
msgid ""
"Format-Decoded-Time formats a string containing decoded-time\n"
"   expressed in a humanly-readable manner.  The destination is any\n"
"   destination which can be accepted by the Format function.  The\n"
"   timezone keyword is an integer specifying hours west of Greenwich.\n"
"   The style keyword can be :short (numeric date), :long (months and\n"
"   weekdays expressed as words), or :abbreviated (like :long but words are\n"
"   abbreviated).  The keyword date-first, if nil, will cause the time\n"
"   to be printed first instead of the date (the default).  The print-\n"
"   keywords, if nil, inhibit the printing of certain semi-obvious\n"
"   parts of the string."
msgstr ""

#: target:code/format-time.lisp
msgid "~A: Seconds should be an integer between 0 and 59."
msgstr ""

#: target:code/format-time.lisp
msgid "~A: Minutes should be an integer between 0 and 59."
msgstr ""

#: target:code/format-time.lisp
msgid "~A: Hours should be an integer between 0 and 23."
msgstr ""

#: target:code/format-time.lisp
msgid "~A: Day should be an integer between 1 and 31."
msgstr ""

#: target:code/format-time.lisp
msgid "~A: Month should be an integer between 1 and 12."
msgstr ""

#: target:code/format-time.lisp
msgid "~A: Hours should be an non-negative integer."
msgstr ""

#: target:code/format-time.lisp
msgid "~A: Timezone should be an integer between 0 and 32."
msgstr ""

#: target:code/foreign.lisp
msgid "Could not create temporary file ~S: ~A"
msgstr ""

#: target:code/foreign.lisp
msgid "Make sure the header starts with the ELF magic value."
msgstr ""

#: target:code/foreign.lisp
msgid "Return the `osabi' field in the padding of the ELF file."
msgstr ""

#: target:code/foreign.lisp
msgid "Given a file type number, determine whether the file is executable."
msgstr ""

#: target:code/foreign.lisp
msgid "Make sure the header starts with the mach-o magic value."
msgstr ""

#: target:code/foreign.lisp
msgid ""
"Parse symbol table file created by load-foreign script.  Modified\n"
"to skip undefined symbols which don't have an address."
msgstr ""

#: target:code/foreign.lisp
msgid ""
"Load-foreign loads a list of C object files into a running Lisp.  The files\n"
"  argument should be a single file or a list of files.  The files may be\n"
"  specified as namestrings or as pathnames.  The libraries argument should "
"be a\n"
"  list of library files as would be specified to ld.  They will be searched "
"in\n"
"  the order given.  The default is just \"-lc\", i.e., the C library.  The\n"
"  base-file argument is used to specify a file to use as the starting place "
"for\n"
"  defined symbols.  The default is the C start up code for Lisp.  The env\n"
"  argument is the Unix environment variable definitions for the invocation "
"of\n"
"  the linker.  The default is the environment passed to Lisp."
msgstr ""

#: target:code/foreign.lisp
msgid "Lazy function call binding"
msgstr ""

#: target:code/foreign.lisp
msgid "Immediate function call binding"
msgstr ""

#: target:code/foreign.lisp
msgid "Mask of binding time value"
msgstr ""

#: target:code/foreign.lisp
msgid ""
"If set the symbols of the loaded object and its dependencies are\n"
"   made visible as if the object were linked directly into the program"
msgstr ""

#: target:code/foreign.lisp
msgid ""
"Load C object files into the running Lisp. The FILES argument\n"
"should be a single file or a list of files. The files may be specified\n"
"as namestrings or as pathnames. The LIBRARIES argument should be a\n"
"list of library files as would be specified to ld. They will be\n"
"searched in the order given. The default is just \"-lc\", i.e., the C\n"
"library. The BASE-FILE argument is used to specify a file to use as\n"
"the starting place for defined symbols. The default is the C start up\n"
"code for Lisp. The ENV argument is the Unix environment variable\n"
"definitions for the invocation of the linker. The default is the\n"
"environment passed to Lisp."
msgstr ""

#: target:code/foreign.lisp
msgid "Can't open global symbol table: ~S"
msgstr ""

#: target:code/foreign.lisp
msgid "Can't open object ~S: ~S"
msgstr ""

#: target:code/foreign.lisp
msgid "LOAD-OBJECT-FILE: Unresolved symbols in file ~S: ~S"
msgstr ""

#: target:code/foreign.lisp
msgid "Couldn't open library ~S: ~S"
msgstr ""

#: target:code/foreign.lisp
msgid "Reloaded library ~S~%"
msgstr ""

#: target:code/foreign.lisp
msgid "Enter new library path: "
msgstr ""

#: target:code/foreign.lisp
msgid ";;; Opening as shared library ~A ...~%"
msgstr ""

#: target:code/foreign.lisp
msgid ";;; Done.~%"
msgstr ""

#: target:code/foreign.lisp
msgid ";;; Trying as object file ~A...~%"
msgstr ""

#: target:code/foreign.lisp
msgid ";;; Running ~A...~%"
msgstr ""

#: target:code/foreign.lisp
msgid "Could not run ~A"
msgstr ""

#: target:code/foreign.lisp
msgid "~A failed:~%~A"
msgstr ""

#: target:code/foreign.lisp
msgid "File does not exist: ~A."
msgstr ""

#: target:code/defstruct.lisp
msgid ""
"Controls compiling DEFSTRUCT :print-function and :print-method\n"
"   options according to ANSI spec. MUST be NIL to compile CMUCL & PCL"
msgstr ""

#: target:code/defstruct.lisp
msgid "Allocate a new instance with LENGTH data slots."
msgstr ""

#: target:code/defstruct.lisp
msgid "Given an instance, return its length."
msgstr ""

#: target:code/defstruct.lisp
msgid "Return the value from the INDEXth slot of INSTANCE.  This is SETFable."
msgstr ""

#: target:code/defstruct.lisp
msgid "Set the INDEXth slot of INSTANCE to NEW-VALUE."
msgstr ""

#: target:code/defstruct.lisp
msgid "Class not yet defined or was undefined: ~S"
msgstr ""

#: target:code/defstruct.lisp
msgid "Class is not a structure class: ~S"
msgstr ""

#: target:code/defstruct.lisp
msgid ""
"DEFSTRUCT {Name | (Name Option*)} {Slot | (Slot [Default] {Key Value}*)}\n"
"   Define the structure type Name.  Instances are created by MAKE-<name>, "
"which\n"
"   takes keyword arguments allowing initial slot values to the specified.\n"
"   A SETF'able function <name>-<slot> is defined for each slot to "
"read&write\n"
"   slot values.  <name>-p is a type predicate.\n"
"\n"
"   Popular DEFSTRUCT options (see manual for others):\n"
"\n"
"   (:CONSTRUCTOR Name)\n"
"   (:PREDICATE Name)\n"
"       Specify an alternate name for the constructor or predicate.\n"
"\n"
"   (:CONSTRUCTOR Name Lambda-List)\n"
"       Explicitly specify the name and arguments to create a BOA "
"constructor\n"
"       (which is more efficient when keyword syntax isn't necessary.)\n"
"\n"
"   (:INCLUDE Supertype Slot-Spec*)\n"
"       Make this type a subtype of the structure type Supertype.  The "
"optional\n"
"       Slot-Specs override inherited slot options.\n"
"\n"
"   Slot options:\n"
"\n"
"   :TYPE Type-Spec\n"
"       Asserts that the value of this slot is always of the specified type.\n"
"\n"
"   :READ-ONLY {T | NIL}\n"
"       If true, no setter function is defined for this slot."
msgstr ""

#: target:code/defstruct.lisp
msgid "defining structure ~A"
msgstr ""

#: target:code/defstruct.lisp
msgid "Defstruct already names a declaration: ~S."
msgstr ""

#: target:code/defstruct.lisp
msgid "Can't have more than one :INCLUDE option."
msgstr ""

#: target:code/defstruct.lisp
msgid "~S is a bad :TYPE for Defstruct."
msgstr ""

#: target:code/defstruct.lisp
msgid "The Defstruct option :NAMED takes no arguments."
msgstr ""

#: target:code/defstruct.lisp
msgid "Unknown DEFSTRUCT option~%  ~S"
msgstr ""

#: target:code/defstruct.lisp
msgid "Unrecognized DEFSTRUCT option: ~S"
msgstr ""

#: target:code/defstruct.lisp
msgid "Can't specify :OFFSET unless :TYPE is specified."
msgstr ""

#: target:code/defstruct.lisp
msgid "Silly to specify :PRINT-FUNCTION with :TYPE."
msgstr ""

#: target:code/defstruct.lisp
msgid "Silly to specify :MAKE-LOAD-FORM-FUN with :TYPE."
msgstr ""

#: target:code/defstruct.lisp
msgid "Duplicate slot name ~S."
msgstr ""

#: target:code/defstruct.lisp
msgid "Slot ~S must be read-only in subtype ~S."
msgstr ""

#: target:code/defstruct.lisp
msgid ""
"Keyword slot name indicates probable syntax ~\n"
"\t\t      error in DEFSTRUCT -- ~S."
msgstr ""

#: target:code/defstruct.lisp
msgid ":TYPE option mismatch between structures ~S and ~S."
msgstr ""

#: target:code/defstruct.lisp
msgid ":TYPE'd defstruct ~S not found for inclusion."
msgstr ""

#: target:code/defstruct.lisp
msgid "(:CONSTRUCTOR NIL) combined with other :CONSTRUCTORs."
msgstr ""

#: target:code/defstruct.lisp
msgid ""
"~@<Non-overwritten accessor ~S does not access ~\n"
"                        slot with name ~S (accessing an inherited slot ~\n"
"                        instead).~:@>"
msgstr ""

#: target:code/defstruct.lisp
msgid "Obsolete structure accessor function called."
msgstr ""

#: target:code/defstruct.lisp
msgid "Structure for accessor ~S is not a ~S:~% ~S"
msgstr ""

#: target:code/defstruct.lisp
msgid "Structure for setter ~S is not a ~S:~% ~S"
msgstr ""

#: target:code/defstruct.lisp
msgid "New-Value for setter ~S is not a ~S:~% ~S."
msgstr ""

#: target:code/defstruct.lisp
msgid "Structure for copier is not a ~S:~% ~S"
msgstr ""

#: target:code/defstruct.lisp
msgid ""
"Shouldn't happen!  Some strange thing in LAYOUT-INFO:~\n"
"\t\t    ~%  ~S"
msgstr ""

#: target:code/defstruct.lisp
msgid ""
"Incompatibly redefining slots of structure class ~S~@\n"
"\t  Make sure any uses of affected accessors are recompiled:~@\n"
"\t  ~@[  These slots were moved to new positions:~%    ~S~%~]~\n"
"\t  ~@[  These slots have new incompatible types:~%    ~S~%~]~\n"
"\t  ~@[  These slots were deleted:~%    ~S~%~]"
msgstr ""

#: target:code/defstruct.lisp
msgid ""
"Redefining class ~S incompatibly with the current ~\n"
"\t\tdefinition."
msgstr ""

#: target:code/defstruct.lisp
msgid "Previously loaded ~S accessors will no longer work."
msgstr ""

#: target:code/defstruct.lisp
msgid ""
"Any old ~S instances will be in a bad way.~@\n"
"\t       I hope you know what you're doing..."
msgstr ""

#: target:code/defstruct.lisp
msgid "Removing old subclasses of ~S:~%  ~S"
msgstr ""

#: target:code/defstruct.lisp
msgid "Return a copy of Structure with the same (EQL) slot values."
msgstr ""

#: target:code/defstruct.lisp
msgid "Copying an obsolete structure:~%  ~S"
msgstr ""

#: target:code/defstruct.lisp
msgid "Structures of type ~S cannot be dumped as constants."
msgstr ""

#: target:code/defmacro.lisp
msgid "A list of tests that do argument counting at expansion time."
msgstr ""

#: target:code/defmacro.lisp
msgid "Let bindings that are done to make lambda-list parsing possible."
msgstr ""

#: target:code/defmacro.lisp
msgid "Let bindings that the user has explicitly supplied."
msgstr ""

#: target:code/defmacro.lisp
msgid "Unsupplied optional and keyword arguments get this value defaultly."
msgstr ""

#: target:code/defmacro.lisp
msgid ""
"Returns as multiple-values a parsed body, any local-declarations that\n"
"   should be made where this body is inserted, and a doc-string if there is\n"
"   one."
msgstr ""

#: target:code/defmacro.lisp
msgid "&Whole must appear first in ~S lambda-list."
msgstr ""

#: target:code/defmacro.lisp
msgid "&environment not valid with ~S."
msgstr ""

#: target:code/defmacro.lisp
msgid "&environment only valid at top level of lambda-list."
msgstr ""

#: target:code/defmacro.lisp
msgid "Invalid ~a"
msgstr ""

#: target:code/defmacro.lisp
msgid "Ignore extra noise."
msgstr ""

#: target:code/defmacro.lisp
msgid ""
"More than variable, initform, and suppliedp ~\n"
"\t\t\t    in &optional binding - ~S"
msgstr ""

#: target:code/defmacro.lisp
msgid "Non-symbol in lambda-list - ~S."
msgstr ""

#: target:code/defmacro.lisp
msgid "Illegal optional variable name: ~S"
msgstr ""

#: target:code/defmacro.lisp
msgid ""
"Takes a non-keyword symbol, symbol, and returns the corresponding keyword."
msgstr ""

#: target:code/defmacro.lisp
msgid "Illegal or ill-formed ~A argument in ~A~@[ ~S~]."
msgstr ""

#: target:code/defmacro.lisp
msgid "Error while parsing arguments to ~A in ~S:~%"
msgstr ""

#: target:code/defmacro.lisp
msgid "Error while parsing arguments to ~A ~S:~%"
msgstr ""

#: target:code/defmacro.lisp
msgid "Bogus sublist:~%  ~S~%to satisfy lambda-list:~%  ~:S~%"
msgstr ""

#: target:code/defmacro.lisp
msgid ""
"Invalid number of elements in:~%  ~:S~%~\n"
"\t     to satisfy lambda-list:~%  ~:S~%"
msgstr ""

#: target:code/defmacro.lisp
msgid "Expected at least ~D"
msgstr ""

#: target:code/defmacro.lisp
msgid "Expected exactly ~D"
msgstr ""

#: target:code/defmacro.lisp
msgid "Expected between ~D and ~D"
msgstr ""

#: target:code/defmacro.lisp
msgid ", but got ~D."
msgstr ""

#~ msgid "Read-Only Space Usage:  ~13:D 바이트 (~4:D 메가바이트의) 아웃.~%"
#~ msgstr "읽기 전용 공간 사용:  ~13:D 바이트 (~4:D 메가바이트의) 아웃.~%"

#~ msgid "Static Space Usage:     ~13:D 바이트 (~4:D 메가바이트의) 아웃.~%"
#~ msgstr "정적 공간을 사용:     ~13:D 바이트 (~4:D 메가바이트의) 아웃.~%"
