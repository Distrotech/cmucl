# $Header: /Volumes/share2/src/cmucl/cvs2git/cvsroot/src/ldb/Attic/Makefile.orig,v 1.2 1990/02/28 18:19:49 wlott Exp $
CFLAGS = -g

OBJS = ldb.o egets.o coreparse.o alloc.o monitor.o print.o os.o vars.o assem.o parse.o interrupt.o test.o

ldb.map: ldb
	echo -n 'Map file for ldb version ' > ldb.map
	cat version >> ldb.map
	nm -gp ldb >> ldb.map


ldb: ${OBJS}
	echo -n '1 + ' | cat - version | bc > ,version
	mv ,version version
	cc ${CFLAGS} -DVERSION=`cat version` -c version.c
	cc -o ,ldb ${OBJS} version.o -lmach -lc
	mv ,ldb ldb


# If we get an interrupt while in lisp code, the global pointer
# is trash.  Therefore, we can't use the GP relative addressing
# mode in the interrupt handlers.

interrupt.o: interrupt.c
	cc ${CFLAGS} -G 0 -c interrupt.c





depends:
	rm -f Makefile.BAK
	ln Makefile Makefile.BAK
	sed -n '1,/^#@/p' Makefile > Makefile.NEW
	cc -M *.[cs] | egrep -v ' /usr/' >> Makefile.NEW
	mv Makefile.NEW Makefile
	rm Makefile.BAK

#@ Do not edit anything after this line.
alloc.o: alloc.c
alloc.o: lisp.h
alloc.o: ldb.h
alloc.o: alloc.h
assem.o: assem.s
assem.o: lisp.h
assem.o: lispregs.h
coreparse.o: coreparse.c
egets.o: egets.c
interrupt.o: interrupt.c
interrupt.o: lisp.h
interrupt.o: ldb.h
interrupt.o: lispregs.h
ldb.o: ldb.c
ldb.o: ldb.h
ldb.o: lisp.h
ldb.o: alloc.h
ldb.o: vars.h
monitor.o: monitor.c
monitor.o: ldb.h
monitor.o: lisp.h
monitor.o: vars.h
monitor.o: parse.h
os.o: os.c
os.o: ldb.h
parse.o: parse.c
parse.o: ldb.h
parse.o: lisp.h
parse.o: vars.h
parse.o: parse.h
print.o: print.c
print.o: ldb.h
print.o: print.h
print.o: lisp.h
print.o: vars.h
search.o: search.c
search.o: lisp.h
search.o: ldb.h
test.o: test.c
test.o: lisp.h
test.o: ldb.h
vars.o: vars.c
vars.o: ldb.h
vars.o: lisp.h
vars.o: vars.h
version.o: version.c
