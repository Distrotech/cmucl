;;; -*- Mode: completion; Log: code.log; Package: debug-internals -*-
;;;
;;; **********************************************************************
;;; This code was written as part of the Spice Lisp project at
;;; Carnegie-Mellon University, and has been placed in the public domain.
;;; Spice Lisp is currently incomplete and under active development.
;;; If you want to use this code or any part of Spice Lisp, please contact
;;; Scott Fahlman (FAHLMAN@CMUC). 
;;; **********************************************************************
;;;
;;; This file contains the implementation of the programmer's interface
;;; to writing debugging tools.
;;;
;;; Written by Bill Chiles.
;;; Designed by Rob Maclachlan and Bill Chiles.
;;;

(in-package "DEBUG-INTERNALS" :nicknames '("DI"))
(use-package "SYSTEM")
(use-package "EXT")
(use-package "KERNEL")

;;; The compiler's debug-source structure is almost exactly what we want, so
;;; just get these symbols and export them.
;;;
(import '(c::debug-source-from c::debug-source-name c::debug-source-created
	  c::debug-source-compiled c::debug-source-start-positions
	  c::make-debug-source c::debug-source c::debug-source-p))

(export '(debug-variable-name debug-variable-package debug-variable-symbol
	  debug-variable-id debug-variable-value debug-variable-validity
	  debug-variable-valid-value debug-variable debug-variable-p

	  top-frame frame-down frame-up frame-debug-function
	  frame-code-location eval-in-frame return-from-frame frame-catches
	  frame-number frame frame-p

	  do-blocks debug-function-lambda-list debug-variable-info-available
	  do-debug-function-variables debug-function-symbol-variables
	  ambiguous-debug-variables preprocess-for-eval function-debug-function
	  debug-function-function debug-function-kind debug-function-name
	  debug-function debug-function-p

	  do-debug-block-locations debug-block-successors debug-block
	  debug-block-p debug-block-elsewhere-p

	  make-breakpoint activate-breakpoint deactivate-breakpoint
	  breakpoint-hook-function breakpoint-info breakpoint-kind
	  breakpoint-what breakpoint breakpoint-p

	  code-location-debug-function code-location-debug-block
	  code-location-top-level-form-offset code-location-form-number
	  code-location-debug-source code-location code-location-p
	  code-location-unknown-p code-location=

	  debug-source-from debug-source-name debug-source-created
	  debug-source-compiled debug-source-root-number
	  debug-source-start-positions form-number-translations
	  source-path-context debug-source debug-source-p

	  debug-condition no-debug-info no-debug-function-returns
	  no-debug-blocks lambda-list-unavailable

	  debug-error unhandled-condition invalid-control-stack-pointer
	  unknown-code-location unknown-debug-variable invalid-value
	  ambiguous-variable-name frame-function-mismatch

	  *debugging-interpreter*))



;;;; Conditions.

;;; The interface to building debugging tools signals conditions that prevent
;;; it from adhering to its contract.  These are serious-conditions because the
;;; program using the interface must handle them before it can correctly
;;; continue execution.  These debugging conditions are not errors since it is
;;; no fault of the programmers that the conditions occur.  The interface does
;;; not provide for programs to detect these situations other than calling a
;;; routine that detects them and signals a condition.  For example,
;;; programmers call A which may fail to return successfully due to a lack of
;;; debug information, and there is no B the they could have called to realize
;;; A would fail.  It is not an error to have called A, but it is an error for
;;; the program to then ignore the signal generated by A since it cannot
;;; continue without A's correctly returning a value or performing some
;;; operation.
;;;
;;; Use DEBUG-SIGNAL to signal these conditions.
;;;

(define-condition debug-condition (serious-condition)
  ()
  (:documentation
   "All debug-conditions inherit from this type.  These are serious conditions
    that must be handled, but they are not programmer errors."))

(define-condition no-debug-info (debug-condition)
  ()
  (:documentation "There is absolutely no debugging information available.")
  (:report (lambda (condition stream)
	     (declare (ignore condition))
	     (write-line "No debugging information available." stream))))

(define-condition no-debug-function-returns (debug-condition)
  (debug-function)
  (:documentation
   "The system could not return values from a frame with debug-function since
    it lacked information about returning values.")
  (:report (lambda (condition stream)
	     (let ((fun (debug-function-function
			 (no-debug-function-returns-debug-function condition))))
	       (format stream
		       "Cannot return values from ~:[frame~;~:*~S~] since the ~
			debug information lacks details about returning values ~
			here."
		       fun)))))

(define-condition no-debug-blocks (debug-condition)
  (debug-function)
  (:documentation "The debug-function has no debug-block information.")
  (:report (lambda (condition stream)
	     (format stream "~S has no debug-block information."
		     (no-debug-blocks-debug-function condition)))))

(define-condition no-debug-variables (debug-condition)
  (debug-function)
  (:documentation "The debug-function has no debug-variable information.")
  (:report (lambda (condition stream)
	     (format stream "~S has no debug-variable information."
		     (no-debug-variables-debug-function condition)))))

(define-condition lambda-list-unavailable (debug-condition)
  (debug-function)
  (:documentation
   "The debug-function has no lambda-list since argument debug-variables are
    unavailable.")
  (:report (lambda (condition stream)
	     (format stream "~S has no lambda-list information available."
		     (lambda-list-unavailable-debug-function condition)))))

(define-condition invalid-value (debug-condition)
  ((debug-variable)
   (frame))
  (:report (lambda (condition stream)
	     (format stream "~S has :invalid or :unknown value in ~S."
		     (invalid-value-debug-variable condition)
		     (invalid-value-frame condition)))))

(define-condition ambiguous-variable-name (debug-condition)
  ((name)
   (frame))
  (:report (lambda (condition stream)
	     (format stream "~S names more than one valid variable in ~S."
		     (ambiguous-variable-name-name condition)
		     (ambiguous-variable-name-frame condition)))))


;;;; Errors and DEBUG-SIGNAL.

;;; The debug internals code tries to signal all programmer errors as
;;; subtypes of debug-error.  There are calls to ERROR signalling simple-errors,
;;; but these dummy checks in the code and shouldn't come up.
;;;
;;; While under development, this code also signals errors in code branches
;;; that remain unimplemented.
;;;

(define-condition debug-error (error) ()
  (:documentation
   "All programmer errors from using the interface for building debugging
    tools inherit from this type."))

(define-condition unhandled-condition (debug-error)
  ((condition))
  (:report (lambda (condition stream)
	     (format stream "~&Unhandled debug-condition:~%~A"
		     condition))))

(define-condition invalid-control-stack-pointer (debug-error)
  ()
  (:report (lambda (condition stream)
	     (declare (ignore condition))
	     (write-string "Invalid control stack pointer." stream))))

(define-condition unknown-code-location (debug-error)
  ((code-location))
  (:report (lambda (condition stream)
	     (format stream "Invalid use of an unknown code-location -- ~S."
		     (unknown-code-location-code-location condition)))))

(define-condition unknown-debug-variable (debug-error)
  ((debug-variable)
   (debug-function))
  (:report (lambda (condition stream)
	     (format stream "~S not in ~S."
		     (unknown-debug-variable-debug-variable condition)
		     (unknown-debug-variable-debug-function condition)))))

(define-condition frame-function-mismatch (debug-error)
  ((code-location)
   (frame)
   (form))
  (:report (lambda (condition stream)
	     (format stream
		     "Form was preprocessed for ~S,~% but called on ~S:~%  ~S"
		     (frame-function-mismatch-code-location condition)
		     (frame-function-mismatch-frame condition)
		     (frame-function-mismatch-form condition)))))


;;; DEBUG-SIGNAL -- Internal.
;;;
;;; This signals debug-conditions.  If they go unhandled, then signal an
;;; unhandled-condition error.
;;;
;;; ??? Get SIGNAL in the right package!
;;;
(defmacro debug-signal (datum &rest arguments)
  `(let ((condition (ext:signal ,datum ,@arguments)))
     (error 'unhandled-condition :condition condition)))



;;;; Structures.

;;; Most of these structures model information stored in internal data
;;; structures created by the compiler.  Whenever comments preface an object or
;;; type with "compiler", they refer to the internal compiler thing, not to the
;;; object or type with the same name in the "DI" package.
;;;


;;;
;;; Debug-variables
;;;

;;; These exist for caching data stored in packed binary form in compiler
;;; debug-functions.  Debug-functions store these.
;;;
(defstruct (debug-variable (:print-function print-debug-variable))
  ;;
  ;; String name of variable.
  (name nil :type simple-string)
  ;;
  ;; String name of package.  Nil when variable's name is uninterned.
  (package nil :type (or null simple-string))
  ;;
  ;; Unique integer identification relative to other variables with the same
  ;; name and package.
  (id 0 :type c::index)
  ;;
  ;; Whether the variable always has a valid value.
  (alive-p nil :type c::boolean))

(defun print-debug-variable (obj str n)
  (declare (ignore n))
  (format str "#<Debug-Variable ~A:~A:~A>"
	  (debug-variable-package obj)
	  (debug-variable-name obj)
	  (debug-variable-id obj)))

(setf (documentation 'debug-variable-name 'function)
  "Returns the name of the debug-variable.  The name is the name of the symbol
   used as an identifier when writing the code.")

(setf (documentation 'debug-variable-package 'function)
  "Returns the package name of the debug-variable.  This is the package name of
   the symbol used as an identifier when writing the code.")

(setf (documentation 'debug-variable-id 'function)
  "Returns the integer that makes debug-variable's name and package name unique
   with respect to other debug-variable's in the same function.")


(defstruct (compiled-debug-variable
	    (:include debug-variable)
	    (:constructor make-compiled-debug-variable
			  (name package id alive-p sc-offset save-sc-offset)))
  ;;
  ;; Storage class and offset.  (unexported).
  (sc-offset nil :type c::sc-offset)
  ;;
  ;; Storage class and offset when saved somewhere.
  (save-sc-offset nil :type (or c::sc-offset null)))

(defstruct (interpreted-debug-variable
	    (:include debug-variable
		      (alive-p t))
	    (:constructor make-interpreted-debug-variable
			  (name package ir1-var)))
  ;;
  ;; This is the IR1 structure that holds information about interpreted vars.
  (ir1-var nil :type c::lambda-var))

;;;
;;; Frames
;;;

;;; These represents call-frames on the stack.
;;;
(defstruct frame
  ;;
  ;; Next frame up.  Null when top frame.
  (up nil :type (or frame null))
  ;;
  ;; Previous frame down.  Nil when the bottom frame.  Before computing the
  ;; next frame down, this slot holds the frame pointer to the control stack
  ;; for the given frame.  This lets us get the next frame down and the
  ;; return-pc for that frame.
  (%down :unparsed :type (or frame (member nil :unparsed)))
  ;;
  ;; Debug-function for function whose call this frame represents.
  (debug-function nil :type debug-function)
  ;;
  ;; Code-location to continue upon return to frame.
  (code-location nil :type code-location)
  ;;
  ;; A-list of catch-tags to code-locations.
  (%catches :unparsed :type (or list (member :unparsed)))
  ;;
  ;; Pointer to frame on control stack.  (unexported)
  ;; When is an interpreted-frame, this is an index into the interpreter's stack.
  pointer
  ;;
  ;; This is the frame's number for prompt printing.  Top is zero.
  number)

(setf (documentation 'frame-up 'function)
  "Returns the frame immediately above frame on the stack.  When frame is
   the top of the stack, this returns nil.")

(setf (documentation 'frame-debug-function 'function)
  "Returns the debug-function for the function whose call frame represents.")

(setf (documentation 'frame-code-location 'function)
  "Returns the code-location where the frame's debug-function will continue
   running when program execution returns to this frame.  If someone
   interrupted this frame, the result could be an unknown code-location.")


(defstruct (compiled-frame
	    (:include frame)
	    (:print-function print-compiled-frame)
	    (:constructor make-compiled-frame
			  (pointer up debug-function code-location number
			   &optional escaped)))
  ;;
  ;; Indicates whether someone interrupted frame.  (unexported).
  ;; If escaped, this is a pointer to the escape frame on the control stack.
  escaped)

(defun print-compiled-frame (obj str n)
  (declare (ignore n))
  (format str "#<Compiled-Frame ~S~:[~;, interrupted~]>"
	  (debug-function-name (frame-debug-function obj))
	  (compiled-frame-escaped obj)))


(defstruct (interpreted-frame
	    (:include frame)
	    (:print-function print-interpreted-frame)
	    (:constructor make-interpreted-frame
			  (pointer up debug-function code-location number
			   real-frame closure)))
  ;;
  ;; This points to the compiled-frame for EVAL:INTERNAL-APPLY-LOOP.
  (real-frame nil :type compiled-frame)
  ;;
  ;; This is the closed over data used by the interpreter.
  (closure nil :type simple-vector))

(defun print-interpreted-frame (obj str n)
  (declare (ignore n))
  (format str "#<Interpreted-Frame ~S>"
	  (debug-function-name (frame-debug-function obj))))

;;;
;;; Debug-functions
;;;

;;; These exist for caching data stored in packed binary form in compiler
;;; debug-functions.  *compiled-debug-functions* maps a c::debug-function to a
;;; debug-function.  There should only be one debug-function in existence for
;;; any function; that is, all code-locations and other objects that reference
;;; debug-functions point to unique objects.  This is due to the overhead in
;;; cached information.
;;;
(defstruct (debug-function (:print-function print-debug-function))
  ;;
  ;; Some representation of the function arguments.  See
  ;; DEBUG-FUNCTION-LAMBDA-LIST.
  ;; NOTE: must parse vars before parsing arg list stuff.
  (%lambda-list :unparsed)
  ;;
  ;; Cached debug-variable information.  (unexported).
  ;; These are sorted by their name.
  (debug-vars :unparsed :type (or simple-vector null (member :unparsed)))
  ;;
  ;; Cached debug-block information.  This is nil when we have tried to parse
  ;; the packed binary info, but none is available.
  (blocks :unparsed :type (or simple-vector null (member :unparsed)))
  ;;
  ;; The actual function if available.
  (%function :unparsed :type (or null function (member :unparsed))))

(defun print-debug-function (obj str n)
  (declare (ignore n))
  (format str "#<~A-Debug-Function ~S>"
	  (etypecase obj
	    (compiled-debug-function "Compiled")
	    (interpreted-debug-function "Interpreted")
	    (bogus-debug-function "Bogus"))
	  (debug-function-name obj)))


(defstruct (compiled-debug-function
	    (:include debug-function)
	    (:constructor %make-compiled-debug-function
			  (compiler-debug-fun component)))
  ;;
  ;; Compiler's dumped debug-function information.  (unexported).
  (compiler-debug-fun nil :type c::compiled-debug-function)
  ;;
  ;; Code object.  (unexported).
  component)

;;; This maps c::compiled-debug-functions to compiled-debug-functions, so we
;;; can get at cached stuff and not duplicate compiled-debug-function
;;; structures.
;;;
(defvar *compiled-debug-functions* (make-hash-table :test #'eq))

;;; MAKE-COMPILED-DEBUG-FUNCTION -- Internal.
;;;
;;; Makes a compiled-debug-function for a c::compiler-debug-function and its
;;; component.  This maps the latter to the former in
;;; *compiled-debug-functions*.  If there already is a compiled-debug-function,
;;; then this returns it from *compiled-debug-functions*.
;;;
(defun make-compiled-debug-function (compiler-debug-fun component)
  (or (gethash compiler-debug-fun *compiled-debug-functions*)
      (setf (gethash compiler-debug-fun *compiled-debug-functions*)
	    (%make-compiled-debug-function compiler-debug-fun component))))


(defstruct (interpreted-debug-function
	    (:include debug-function)
	    (:constructor %make-interpreted-debug-function (ir1-lambda)))
  ;;
  ;; This is the ir1 lambda this debug-function represents.
  (ir1-lambda nil :type c::clambda))

(defstruct (bogus-debug-function
	    (:include debug-function)
	    (:constructor make-bogus-debug-function
			  (%name &aux (%lambda-list nil) (debug-vars nil)
				 (blocks nil) (%function nil))))
  %name)

(defvar *ir1-lambda-debug-function* (make-hash-table :test #'eq))

(defun make-interpreted-debug-function (ir1-lambda)
  (let ((home-lambda (c::lambda-home ir1-lambda)))
    (or (gethash home-lambda *ir1-lambda-debug-function*)
	(setf (gethash home-lambda *ir1-lambda-debug-function*)
	      (%make-interpreted-debug-function home-lambda)))))

;;;
;;; Debug-blocks.
;;;

;;; These exist for caching data stored in packed binary form in compiler
;;; debug-blocks.
;;;
(defstruct (debug-block (:print-function print-debug-block))
  ;;
  ;; Code-locations where execution continues after this block.
  (successors nil :type list)
  ;;
  ;; This indicates whether the block is a special glob of code shared by
  ;; various functions and tucked away elsewhere in a component.  This kind of
  ;; block has no start code-location.  In an interpreted-debug-block, this is
  ;; always nil.  This slot is in all debug-blocks since it is an exported
  ;; interface.
  (elsewhere-p nil :type c::boolean))

(defun print-debug-block (obj str n)
  (declare (ignore n))
  (format str "#<~A-Debug-Block ~S>"
	  (etypecase obj
	    (compiled-debug-block "Compiled")
	    (interpreted-debug-block "Interpreted"))
	  (debug-block-function-name obj)))

(setf (documentation 'debug-block-successors 'function)
  "Returns the list of possible code-locations where execution may continue
   when the basic-block represented by debug-block completes its execution.")

(setf (documentation 'debug-block-elsewhere-p 'function)
  "Returns whether debug-block represents elsewhere code.")


(defstruct (compiled-debug-block (:include debug-block)
				 (:constructor
				  make-compiled-debug-block
				  (code-locations successors elsewhere-p)))
  ;;
  ;; Code-location information for the block.
  (code-locations nil :type simple-vector))

(defstruct (interpreted-debug-block (:include debug-block
					      (elsewhere-p nil))
				    (:constructor %make-interpreted-debug-block
						  (ir1-block)))
  ;;
  ;; This is the IR1 block this debug-block represents.
  (ir1-block nil :type c::cblock)
  ;;
  ;; Code-location information for the block.
  (locations :unparsed :type (or (member :unparsed) simple-vector)))

(defvar *ir1-block-debug-block* (make-hash-table :test #'eq))

;;; MAKE-INTERPRETED-DEBUG-BLOCK -- Internal.
;;;
;;; This makes a debug-block for the interpreter's ir1-block.  If we have it in
;;; the cache, return it.  If we need to make it, then first make debug-blocks
;;; for all the ir1-blocks in ir1-block's home lambda; this makes sure all the
;;; successors of ir1-block have debug-blocks.  We need this to fill in the
;;; resulting debug-block's successors list with debug-blocks, not ir1-blocks.
;;; After making all the possible debug-blocks we'll need to reference, go back
;;; over the list of new debug-blocks and fill in their successor slots with
;;; lists of debug-blocks.  Then look up our argument ir1-block to find its
;;; debug-block since we know we have it now.
;;;
(defun make-interpreted-debug-block (ir1-block)
  (check-type ir1-block c::cblock)
  (let ((res (gethash ir1-block *ir1-block-debug-block*)))
    (or res
	(let ((lambda (c::block-home-lambda ir1-block)))
	  (c::do-blocks (block (c::block-component ir1-block))
	    (when (eq lambda (c::block-home-lambda block))
	      (push (setf (gethash block *ir1-block-debug-block*)
			  (%make-interpreted-debug-block block))
		    res)))
	  (dolist (block res)
	    (let ((successors nil))
	      (dolist (succ (c::block-succ
			     (interpreted-debug-block-ir1-block block)))
		(let ((dblock (gethash succ *ir1-block-debug-block*)))
		  (unless dblock
		    (error "Block ~S has successor ~S in different lambda."
			   (interpreted-debug-block-ir1-block block) succ))
		  (push dblock successors)))
	      (setf (debug-block-successors block) (nreverse successors))))
	  (gethash ir1-block *ir1-block-debug-block*)))))

;;;
;;; Breakpoints.
;;;

(defstruct (breakpoint (:print-function print-breakpoint)
		       (:constructor %make-breakpoint))
  hook-function	      ;Function takes frame, breakpoint, and optional values.
  what		      ;Code-location or debug-function.
  kind		      ;:code-location, :function-start, or :function-end.
  info		      ;User settable and usable information.
  active-p)	      ;Whether this breakpoint is in effect.

(defun print-breakpoint (obj str n)
  (declare (ignore n))
  (let ((what (breakpoint-what obj)))
    (format str "#<Breakpoint ~S~:[~;~:*~S~]>"
	    (etypecase what
	      (code-location what)
	      (debug-function (debug-function-name what)))
	    (etypecase what
	      (code-location nil)
	      (debug-function (breakpoint-kind obj))))))

;;;
;;; Code-locations.
;;;

(defstruct (code-location (:print-function print-code-location))
  ;;
  ;; This is the debug-function containing code-location.
  (debug-function nil :type debug-function)
  ;;
  ;; This is initially :unsure.  Upon first trying to access an :unparsed slot,
  ;; if the data is unavailable, then this becomes t, and the code-location is
  ;; unknown.  If the data is available, this becomes nil, a known location.
  ;; We can't use a separate type code-location for this since we must return
  ;; code-locations before we can tell whether they're known or unknown.  For
  ;; example, when parsing the stack, we don't want to unpack all the variables
  ;; and blocks just to make frames.
  (%unknown-p :unsure :type (member t nil :unsure))
  ;;
  ;; This is the debug-block containing code-location.
  ;; Possibly toss this out and just find it in the blocks cache in
  ;; debug-function.
  (%debug-block :unparsed :type (or debug-block (member :unparsed)))
  ;;
  ;; This is the number of forms processed by the compiler or loader before
  ;; the top-level form containing this code-location.
  (%tlf-offset :unparsed :type (or c::index (member :unparsed)))
  ;;
  ;; This is the depth-first number of the node that begins code-location
  ;; within its top-level form.
  (%form-number :unparsed :type (or c::index (member :unparsed))))

(defun print-code-location (obj str n)
  (declare (ignore n))
  (format str "#<~A ~S>"
	  (ecase (code-location-unknown-p obj)
	    ((nil) (etypecase obj
		     (compiled-code-location "Compiled-Code-Location")
		     (interpreted-code-location "Interpreted-Code-Location")))
	    ((t) "Unknown-Code-Location"))
	  (debug-function-name (code-location-debug-function obj))))

(setf (documentation 'code-location-debug-function 'function)
  "Returns the debug-function representing information about the function
   corresponding to the code-location.")


(defstruct (compiled-code-location
	    (:include code-location)
	    (:constructor make-compiled-code-location
			  (pc debug-function &optional
			      %tlf-offset %form-number %live-set kind
			      ;; Any optional means it's known.
			      (%unknown-p (not kind))))
	    (:constructor make-unknown-code-location
			  (pc debug-function &aux (%unknown-p :unsure))))
  ;;
  ;; This is an index into debug-function's component slot.
  (pc nil :type c::index)
  ;;
  ;; This is a bit-vector indexed by a variable's position in
  ;; DEBUG-FUNCTION-DEBUG-VARS indicating whether the variable has a valid
  ;; value at this code-location.  (unexported).
  (%live-set :unparsed :type (or simple-bit-vector (member :unparsed)))
  ;;
  ;; (unexported)
  (kind :unparsed :type (member :unparsed :unknown-return :known-return
				:internal-error :non-local-exit :block-start)))

(defstruct (interpreted-code-location
	    (:include code-location
		      (%unknown-p nil))
	    (:constructor make-interpreted-code-location
			  (ir1-node debug-function)))
  ;;
  ;; This is an index into debug-function's component slot.
  (ir1-node nil :type c::node))
  

;;;
;;; Debug-sources
;;;

(proclaim '(inline debug-source-root-number))
;;;
(defun debug-source-root-number (debug-source)
  "Returns the number of top-level forms processed by the compiler before
   compiling this source.  If this source is uncompiled, this is zero.  This
   may be zero even if the source is compiled since the first form in the first
   file compiled in one compilation, for example, must have a root number of
   zero -- the compiler saw no other top-level forms before it."
  (c::debug-source-source-root debug-source))

(setf (documentation 'c::debug-source-from 'function)
  "Returns an indication of the type of source.  The following are the possible
   values:
      :file    from a file (obtained by COMPILE-FILE if compiled).
      :lisp    from Lisp (obtained by COMPILE if compiled).
      :stream  from a non-file stream.")

(setf (documentation 'c::debug-source-name 'function)
  "Returns the actual source in some sense represented by debug-source, which
   is related to DEBUG-SOURCE-FROM:
      :file    the pathname of the file.
      :lisp    a lambda-expression.
      :stream  some descriptive string that's otherwise useless.")

(setf (documentation 'c::debug-source-created 'function)
  "Returns the universal time someone created the source.  This may be nil if
   it is unavailable.")

(setf (documentation 'c::debug-source-compiled 'function)
  "Returns the time someone compiled the source.  This is nil if the source
   is uncompiled.")

(setf (documentation 'c::debug-source-start-positions 'function)
  "This function returns the file position of each top-level form as an array
   if debug-source is from a :file.  If DEBUG-SOURCE-FROM is :lisp or :stream,
   this returns nil.")

(setf (documentation 'c::debug-source-p 'function)
  "Returns whether object is a debug-source.")



;;;; Frames.

;;; These are magically converted by the compiler.
;;;
(defun current-sp () (current-sp))
(defun current-fp () (current-fp))
(defun stack-ref (s n) (stack-ref s n))
(defun %set-stack-ref (s n value) (%set-stack-ref s n value))
(defun function-code-header (fun) (function-code-header fun))
(defun lra-code-header (lra) (lra-code-header lra))
(defun make-lisp-obj (value) (make-lisp-obj value))
(defun get-lisp-obj-address (thing) (get-lisp-obj-address thing))
;;;
(defsetf stack-ref %set-stack-ref)

(def-c-variable "control_stack" system-area-pointer)

(proclaim '(inline cstack-pointer-valid-p))
(defun cstack-pointer-valid-p (x)
  (declare (type system-area-pointer x))
  (and (pointer< x (current-sp))
       (not (pointer< x (alien-access (alien-value control_stack))))))


(def-c-array interrupt-array mach:*sigcontext 4096)

(def-c-variable "lisp_interrupt_contexts" interrupt-array)


;;; These are the names of all the functions that the system could have called
;;; while interpreting.  We need to detect these when parsing the stack and
;;; make frames representing the code the intepreter is evaluating.

;;; FRAME-REAL-FRAME  --  Internal
;;;
;;;    If an interpreted frame, return the real frame, otherwise frame.
;;;
(defun frame-real-frame (frame)
  (etypecase frame
    (compiled-frame frame)
    (interpreted-frame (interpreted-frame-real-frame frame))))

;;; TOP-FRAME -- Public.
;;;
(defun top-frame ()
  "Returns the top frame of the control stack as it was before calling this
   function."
  (multiple-value-bind (fp pc)
		       (kernel:%caller-frame-and-pc)
    (possibly-an-interpreted-frame
     (compute-calling-frame (int-sap (* (truly-the fixnum fp) vm:word-bytes))
			    pc nil)
     nil)))


;;; GET-CONTEXT-VALUE  --  Internal
;;;
;;;    Get the old FP or return PC out of Frame.  Stack-Slot is offset the
;;; standard save location on the stack.  Loc the the saved SC-Offset
;;; describing the main location.
;;;
(defun get-context-value (frame stack-slot loc)
  (declare (type compiled-frame frame) (type unsigned-byte stack-slot)
	   (type c::sc-offset loc))
  (let ((pointer (frame-pointer frame))
	(escaped (compiled-frame-escaped frame)))
    (if escaped
	(sub-access-debug-var-slot pointer loc escaped)
	(stack-ref pointer stack-slot))))

  
;;; FRAME-DOWN -- Public.
;;;
;;;    We have to access the old-fp and return-pc out of Frame and pass them to
;;; COMPUTE-CALLING-FRAME.
;;;
(defun frame-down (frame)
  "Returns the frame immediately below frame on the stack.  When frame is
   the bottom of the stack, this returns nil."
  (let ((down (frame-%down frame)))
    (if (eq down :unparsed)
	(let* ((real (frame-real-frame frame))
	       (debug-fun (frame-debug-function real)))
	  (setf (frame-%down frame)
		(etypecase debug-fun
		  (compiled-debug-function
		   (let ((c-d-f (compiled-debug-function-compiler-debug-fun
				 debug-fun)))
		     (possibly-an-interpreted-frame
		      (compute-calling-frame
		       (int-sap (* (get-context-value
				    real
				    vm::old-fp-save-offset
				    (c::compiled-debug-function-old-fp c-d-f))
				   vm:word-bytes))
		       (get-context-value
			real
			vm::lra-save-offset
			(c::compiled-debug-function-return-pc c-d-f))
		       frame)
		      frame)))
		  (bogus-debug-function
		   (let ((fp (frame-pointer real)))
		     (compute-calling-frame (sap-ref-sap fp
							 vm::old-fp-save-offset)
					    (stack-ref fp vm::lra-save-offset)
					    frame))))))
	down)))

;;; CODE-OBJECT-FROM-BITS  --  internal.
;;;
;;; Find the code object corresponding to the object represented by bits and
;;; return it.  We assume bogus functions correspond to the
;;; undefined-function.
;;; 
(defun code-object-from-bits (bits)
  (declare (type (unsigned-byte 32) bits))
  (let ((object (make-lisp-obj bits)))
    (if (functionp object)
	(or (function-code-header object)
	    :undefined-function)
	(let ((lowtag (get-lowtag object)))
	  (if (= lowtag vm:other-pointer-type)
	      (let ((type (get-type object)))
		(cond ((= type vm:code-header-type)
		       object)
		      ((= type vm:return-pc-header-type)
		       (lra-code-header object))
		      (t
		       nil))))))))

(defun find-escaped-frame (frame-pointer)
  (declare (type system-area-pointer frame-pointer))
  (dotimes (index lisp::*free-interrupt-context-index*
		  (values nil 0 nil))
    (alien-bind ((scp (interrupt-array-ref
		       (alien-value lisp_interrupt_contexts)
		       index)
		      (alien mach:sigcontext 2400)
		      t)
		 (sc (mach:indirect-*sigcontext scp)
		     mach:sigcontext
		     t)
		 (regs (mach:sigcontext-regs (alien-value sc))
		       mach:int-array
		       t))
      (when (= (sap-int frame-pointer)
	       (alien-access
		(mach:int-array-ref regs vm::fp-offset)))
	(system:without-gcing
	 (let ((code (code-object-from-bits
		      (alien-access
		       (mach:int-array-ref regs vm::code-offset)))))
	   (when (symbolp code)
	     (return (values code 0 (alien-value sc))))
	   (let* ((code-header-len (* (get-header-data code) vm:word-bytes))
		  (pc-offset
		   (- (sap-int
		       (alien-access
			(mach:sigcontext-pc (alien-value sc))))
		      (- (get-lisp-obj-address code) vm:other-pointer-type)
		      code-header-len)))
	     ;; Check to see if we were executing in a branch delay slot.
	     (when (logbitp 31 (alien-access
				(mach:sigcontext-cause (alien-value sc))))
	       (incf pc-offset vm:word-bytes))
	     (unless (<= 0
			 pc-offset
			 (* (truly-the lisp::index
				       (%primitive c::code-code-size code))
			    vm:word-bytes))
	       ;; We were in an assembly routine.  Therefore, use the LRA as
	       ;; the pc.
	       (setf pc-offset
		     (- (escape-register (alien-value sc)
					 vm::lra-offset)
			(get-lisp-obj-address code)
			code-header-len)))
	     (return
	      (values code
		      pc-offset
		      (alien-value sc))))))))))

(defvar *debugging-interpreter* nil
  "When set, the debugger foregoes making interpreted-frames, so you can
   debug the functions that manifest the interpreter.")

;;; POSSIBLY-AN-INTERPRETED-FRAME -- Internal.
;;;
;;; This takes a newly computed frame, frame, and the frame above it on the
;;; stack, up-frame, which is possibly nil.  Frame is nil when we hit the
;;; bottom of the control stack.  When frame represents a call to
;;; EVAL::INTERNAL-APPLY-LOOP, we make an interpreted frame to replace frame.
;;; The interpreted frame points to frame.
;;;
(defun possibly-an-interpreted-frame (frame up-frame)
  (if (or (not frame)
	  (not (eq (debug-function-name (frame-debug-function frame))
		   'eval::internal-apply-loop))
	  *debugging-interpreter*
	  (compiled-frame-escaped frame))
      frame
      (flet ((get-var (name location)
	       (let ((vars (di:ambiguous-debug-variables
			    (di:frame-debug-function frame) name)))
		 (when (or (null vars) (> (length vars) 1))
		   (error "Zero or more than one ~A variable in ~
			   EVAL::INTERNAL-APPLY-LOOP?"
			  (string-downcase name)))
		 (if (eq (debug-variable-validity (car vars) location)
			 :valid)
		     (car vars)))))
	(let* ((code-loc (frame-code-location frame))
	       (ptr-var (get-var "FRAME-PTR" code-loc))
	       (node-var (get-var "NODE" code-loc))
	       (closure-var (get-var "CLOSURE" code-loc)))
	  (if (and ptr-var node-var closure-var)
	      (let* ((node (debug-variable-value node-var frame))
		     (d-fun (make-interpreted-debug-function
			     (c::block-home-lambda (c::node-block node)))))
		(make-interpreted-frame
		 (debug-variable-value ptr-var frame)
		 up-frame
		 d-fun
		 (make-interpreted-code-location node d-fun)
		 (frame-number frame)
		 frame
		 (debug-variable-value closure-var frame)))
	      frame)))))

;;; COMPUTE-CALLING-FRAME -- Internal.
;;;
;;; This returns a frame for the one existing in time immediately prior to the
;;; frame referenced by current-fp.  This is current-fp's caller or the next
;;; frame down the control stack.  If there is no down frame, this returns nil
;;; for the bottom of the stack.  Up-frame is the up link for the resulting
;;; frame object, and it is nil when we call this to get the top of the stack.
;;;
;;; The current frame contains the pointer to the temporally previous frame we
;;; want, and the current frame contains the pc at which we will continue
;;; executing upon returning to that previous frame.
;;;
(defun compute-calling-frame (caller lra up-frame)
  (declare (type system-area-pointer caller))
  (when (cstack-pointer-valid-p caller)
    (multiple-value-bind
	(code pc-offset escaped)
	(if lra
	    (let ((word-offset (get-header-data lra))
		  (code (lra-code-header lra)))
	      (if code
		  (values code
			  (* (1+ (- word-offset (get-header-data code)))
			     vm:word-bytes)
			  nil)
		  (values :foreign-function
			  0
			  nil)))
	    (find-escaped-frame caller))
      (let ((d-fun (case code
		     (:undefined-function
		      (make-bogus-debug-function
		       "The Undefined Function"))
		     (:foreign-function
		      (make-bogus-debug-function
		       "Foreign function call land"))
		     ((nil)
		      (make-bogus-debug-function
		       "Bogus stack frame"))
		     (t
		      (debug-function-from-pc code pc-offset)))))
	(make-compiled-frame caller up-frame d-fun
			     (code-location-from-pc d-fun pc-offset escaped)
			     (if up-frame (1+ (frame-number up-frame)) 0)
			     escaped)))))


;;;
;;; Frame utilities.
;;;

;;; ESCAPE-REGISTER -- Internal.
;;;
;;; An escape register saves the value of a register for a frame that someone
;;; interrupts.  
;;;
(defun escape-register (scp index)
  (alien-bind ((sc scp mach:sigcontext t)
	       (regs (mach:sigcontext-regs (alien-value sc)) mach:int-array t))
    (alien-access (mach:int-array-ref (alien-value regs) index))))

(defun %set-escape-register (scp index new)
  (alien-bind ((sc scp mach:sigcontext t)
	       (regs (mach:sigcontext-regs (alien-value sc)) mach:int-array t))
    (setf (alien-access (mach:int-array-ref (alien-value regs) index)) new)))

(defsetf escape-register %set-escape-register)


;;; ESCAPE-FLOAT-REGISTER  --  Internal
;;;
;;;    Like ESCAPE-REGISTER, but returns the value of a float register.  Format
;;; is the type of float to return.
;;;
(defun escape-float-register (scp index format)
  (alien-bind ((sc scp mach:sigcontext t)
	       (fpregs (mach:sigcontext-fpregs (alien-value sc))
		       mach:int-array t))
    (let ((sap (alien-sap fpregs)))
      (ecase format
	(single-float (sap-ref-single sap index))
	(double-float (sap-ref-double sap index))))))
;;;
(defun %set-escape-float-register (scp index format new-value)
  (alien-bind ((sc scp mach:sigcontext t)
	       (fpregs (mach:sigcontext-fpregs (alien-value sc))
		       mach:int-array t))
    (let ((sap (alien-sap fpregs)))
      (ecase format
	(single-float
	 (setf (sap-ref-single sap index) new-value))
	(double-float
	 (setf (sap-ref-double sap index) new-value))))))
;;;
(defsetf escape-float-register %set-escape-float-register)


;;; DEBUG-FUNCTION-FROM-PC -- Internal.
;;;
;;; This returns a compiled-debug-function for code and pc.  We fetch the
;;; c::debug-info and run down its function-map to get a
;;; c::compiled-debug-function from the pc.  The result only needs to reference
;;; the component, for function constants, and the c::compiled-debug-function.
;;;
(defun debug-function-from-pc (component pc)
  (let ((info (code-debug-info component)))
    (unless info
      (debug-signal 'no-debug-info))
    (let* ((function-map (c::compiled-debug-info-function-map info))
	   (len (length function-map)))
      (declare (simple-vector function-map))
      (if (= len 1)
	  (make-compiled-debug-function (svref function-map 0) component)
	  (let ((i 1)
		(elsewhere-p
		 (>= pc (c::compiled-debug-function-elsewhere-pc
			 (svref function-map 0)))))
	    (declare (type c::index i))
	    (loop
	      (when (or (= i len)
			(< pc (if elsewhere-p
				  #+rt-target
				  (1+ (c::compiled-debug-function-elsewhere-pc
				       (svref function-map (1+ i))))
				  #-rt-target
				  (c::compiled-debug-function-elsewhere-pc
				   (svref function-map (1+ i)))
				  (svref function-map i))))
		(return (make-compiled-debug-function
			 (svref function-map (1- i))
			 component)))
	      (incf i 2)))))))

;;; CODE-LOCATION-FROM-PC -- Internal.
;;;
;;; This returns a code-location for the compiled-debug-function, debug-fun,
;;; and the pc into its code vector.  If there is debug-block info, we assume
;;; the code-location is known by making a default one.  It may later prove
;;; to be unknown as :unparsed slots are accessed.  Code locations in bogus
;;; debug funs are always unknown.
;;;
(defun code-location-from-pc (debug-fun pc escaped)
  (if (and (compiled-debug-function-p debug-fun)
	   (c::compiled-debug-function-blocks
	    (compiled-debug-function-compiler-debug-fun debug-fun))
	   (not escaped))
      (make-compiled-code-location pc debug-fun)
      (make-unknown-code-location pc debug-fun)))


;;; FRAME-CATCHES -- Public.
;;;
(defun frame-catches (frame)
  "Returns an a-list mapping catch tags to code-locations.  These are
   code-locations at which execution would continue with frame as the top
   frame if someone threw to the corresponding tag."
  (let ((catch (int-sap (* lisp::*current-catch-block* vm:word-bytes)))
	(res nil)
	(fp (etypecase frame
	      (compiled-frame (frame-pointer frame))
	      (interpreted-frame (frame-pointer
				  (interpreted-frame-real-frame frame))))))
    (loop
      (when (eql catch 0) (return (nreverse res)))
      (when (eq fp (stack-ref catch vm:catch-block-current-cont-slot))
	(let* ((lra (stack-ref catch vm:catch-block-entry-pc-slot))
	       (word-offset (get-header-data lra)))
	  (push (cons (stack-ref catch vm:catch-block-tag-slot)
		      (make-compiled-code-location
		       (* word-offset vm:word-bytes)
		       (frame-debug-function frame)))
		res)))
      (setf catch (stack-ref catch vm:catch-block-previous-catch-slot)))))



;;;; Debug-functions.

;;; DO-BLOCKS -- Public.
;;;
(defmacro do-blocks ((block-var debug-function &optional result) &body body)
  "Executes the forms in a context with block-var bound to each debug-block
   in debug-function successively.  Result is an optional form to execute for
   return values, and DO-BLOCKS returns nil if there is no result form.  This
   signals a no-debug-blocks condition when the debug-function lacks
   debug-block information."
  (let ((blocks (gensym))
	(i (gensym)))
    `(let ((,blocks (debug-function-debug-blocks ,debug-function)))
       (declare (simple-vector ,blocks))
       (dotimes (,i (length ,blocks) ,result)
	 (let ((,block-var (svref ,blocks ,i)))
	   ,@body)))))

;;; DO-DEBUG-FUNCTION-VARIABLES -- Public.
;;;
(defmacro do-debug-function-variables ((var debug-function &optional result)
				       &body body)
  "Executes body in a context with var bound to each debug-variable in
   debug-function.  This returns the value of executing result (defaults to
   nil).  This may iterate over only some of debug-function's variables or none
   depending on debug policy; for example, possibly the compilation only
   preserved argument information."
  (let ((vars (gensym))
	(i (gensym)))
    `(let ((,vars (debug-function-debug-variables ,debug-function)))
       (declare (type (or null simple-vector) ,vars))
       (if ,vars
	   (dotimes (,i (length ,vars) ,result)
	     (let ((,var (svref ,vars ,i)))
	       ,@body))
	   ,result))))

;;; DEBUG-FUNCTION-FUNCTION -- Public.
;;;
;;; ### Should hack compiled functions someday, now that the new object format
;;; allows it.
;;;
(defun debug-function-function (debug-function)
  "Returns the Common Lisp function associated with the debug-function.  This
   returns nil if the function is unavailable or is non-existent as a user
   callable function object."
  (let ((cached-value (debug-function-%function debug-function)))
    (if (eq cached-value :unparsed)
	(setf (debug-function-%function debug-function)
	      (etypecase debug-function
		(compiled-debug-function nil)
		(interpreted-debug-function
		 (c::lambda-eval-info-function
		  (c::leaf-info
		   (interpreted-debug-function-ir1-lambda debug-function))))
		(bogus-debug-function nil)))
	cached-value)))


;;; DEBUG-FUNCTION-NAME -- Public.
;;;
(defun debug-function-name (debug-function)
  "Returns the name of the function represented by debug-function.  This may
   be a string or a cons; do not assume it is a symbol."
  (etypecase debug-function
    (compiled-debug-function
     (c::compiled-debug-function-name
      (compiled-debug-function-compiler-debug-fun debug-function)))
    (interpreted-debug-function
     (c::lambda-name (interpreted-debug-function-ir1-lambda debug-function)))
    (bogus-debug-function
     (bogus-debug-function-%name debug-function))))


;;; FUNCTION-DEBUG-FUNCTION -- Public.
;;;
(defun function-debug-function (fun)
  "Returns a debug-function that represents debug information for function."
  (if (eval:interpreted-function-p fun)
      (let ((eval-fun (eval::get-eval-function fun)))
	(make-interpreted-debug-function
	 (or (eval::eval-function-definition eval-fun)
	     (eval::convert-eval-fun eval-fun))))
      (let ((code (function-code-header fun)))
	(debug-function-from-pc
	 code
	 (* (- (get-header-data fun) (get-header-data code))
	    vm:word-bytes)))))


;;; DEBUG-FUNCTION-KIND -- Public.
;;;
(defun debug-function-kind (debug-function)
  "Returns the kind of the function which is one of :optional, :external,
   :top-level, :cleanup, nil."
  (etypecase debug-function
    (compiled-debug-function
     (c::compiled-debug-function-kind
      (compiled-debug-function-compiler-debug-fun debug-function)))
    (interpreted-debug-function
     (c::lambda-kind (interpreted-debug-function-ir1-lambda debug-function)))
    (bogus-debug-function
     nil)))

;;; DEBUG-VARIABLE-INFO-AVAILABLE -- Public.
;;;
(defun debug-variable-info-available (debug-function)
  "Returns whether there is any variable information for debug-function."
  (not (not (debug-function-debug-variables debug-function))))

;;; DEBUG-FUNCTION-SYMBOL-VARIABLES -- Public.
;;;
(defun debug-function-symbol-variables (debug-function symbol)
  "Returns a list of debug-variables in debug-function having the same name
   and package as symbol.  If symbol is uninterned, then this returns a list of
   debug-variables without package names and with the same name as symbol.  The
   result of this function is limited to the availability of variable
   information in debug-function; for example, possibly debug-function only
   knows about its arguments."
  (let ((vars (ambiguous-debug-variables debug-function (symbol-name symbol)))
	(package (if (symbol-package symbol)
		     (package-name (symbol-package symbol)))))
    (delete-if (if (stringp package)
		   #'(lambda (var)
		       (let ((p (debug-variable-package var)))
			 (or (not (stringp p))
			     (string/= p package))))
		   #'(lambda (var)
		       (stringp (debug-variable-package var))))
	       vars)))

;;; AMBIGUOUS-DEBUG-VARIABLES -- Public.
;;;
(defun ambiguous-debug-variables (debug-function name-prefix-string)
   "Returns a list of debug-variables in debug-function whose names contain
    name-prefix-string as an intial substring.  The result of this function is
    limited to the availability of variable information in debug-function; for
    example, possibly debug-function only knows about its arguments."
  (declare (simple-string name-prefix-string))
  (let ((variables (debug-function-debug-variables debug-function)))
    (declare (type (or null simple-vector) variables))
    (if variables
	(let* ((len (length variables))
	       (prefix-len (length name-prefix-string))
	       (pos (find-variable name-prefix-string variables len))
	       (res nil))
	  (when pos
	    ;; Find names from pos to variable's len that contain prefix.
	    (do ((i pos (1+ i)))
		((= i len))
	      (let* ((var (svref variables i))
		     (name (debug-variable-name var))
		     (name-len (length name)))
		(declare (simple-string name))
		(when (/= (or (string/= name-prefix-string name
					:end1 prefix-len :end2 name-len)
			      prefix-len)
			  prefix-len)
		  (return))
		(push var res)))
	    (setq res (nreverse res)))
	  res))))

;;; FIND-VARIABLE -- Internal.
;;;
;;; This returns a position in variables for one containing name as an initial
;;; substring.  End is the length of variables if supplied.
;;;
(defun find-variable (name variables &optional end)
  (declare (simple-vector variables)
	   (simple-string name))
  (let ((name-len (length name)))
    (position name variables
	      :test #'(lambda (x y)
			(let* ((y (debug-variable-name y))
			       (y-len (length y)))
			  (declare (simple-string y))
			  (and (>= y-len name-len)
			       (string= x y :end1 name-len :end2 name-len))))
	      :end (or end (length variables)))))

;;; DEBUG-FUNCTION-LAMBDA-LIST -- Public.
;;;
(defun debug-function-lambda-list (debug-function)
  "Returns a list representing the lambda-list for debug-function.  The list
   has the following structure:
      (required-var1 required-var2
       ...
       (:optional var3 suppliedp-var4)
       (:optional var5)
       ...
       (:rest var6) (:rest var7)
       ...
       (:keyword keyword-symbol var8 suppliedp-var9)
       (:keyword keyword-symbol var10)
       ...
      )
   Each VARi is a debug-variable; however it may be the symbol :deleted it
   is unreferenced in debug-function.  This signals a lambda-list-unavaliable
   condition when there is no argument list information."
  (etypecase debug-function
    (compiled-debug-function
     (compiled-debug-function-lambda-list debug-function))
    (interpreted-debug-function
     (interpreted-debug-function-lambda-list debug-function))
    (bogus-debug-function
     nil)))

;;; INTERPRETED-DEBUG-FUNCTION-LAMBDA-LIST -- Internal.
;;; 
;;; The hard part is when the lambda-list is unparsed.  If it is unparsed,
;;; and all the arguments are required, this is still pretty easy; just
;;; whip the appropriate debug-variables into a list.  Otherwise, we have
;;; to pick out the funny arguments including any suppliedp variables.  In
;;; this situation, the ir1-lambda is an external entry point that takes
;;; arguments users really pass in.  It looks at those and computes defaults
;;; and suppliedp variables, ultimately passing everything defined as a
;;; a parameter to the real function as final arguments.  If this has to
;;; compute the lambda list, it caches it in debug-function.
;;;
(defun interpreted-debug-function-lambda-list (debug-function)
  (let ((lambda-list (debug-function-%lambda-list debug-function))
	(debug-vars (debug-function-debug-variables debug-function))
	(ir1-lambda (interpreted-debug-function-ir1-lambda debug-function))
	(res nil))
    (if (eq lambda-list :unparsed)
	(flet ((frob (v debug-vars)
		 (if (c::lambda-var-refs v)
		     (find v debug-vars
			   :key #'interpreted-debug-variable-ir1-var)
		     :deleted)))
	  (let ((xep-args (c::lambda-optional-dispatch ir1-lambda)))
	    (if (and xep-args
		     (eq (c::optional-dispatch-main-entry xep-args) ir1-lambda))
		;;
		;; There are rest, optional, keyword, and suppliedp vars.
		(let ((final-args (c::lambda-vars ir1-lambda)))
		  (dolist (xep-arg (c::optional-dispatch-arglist xep-args))
		    (let ((info (c::lambda-var-arg-info xep-arg))
			  (final-arg (pop final-args)))
		      (cond (info
			     (case (c::arg-info-kind info)
			       (:required
				(push (frob final-arg debug-vars) res))
			       (:keyword
				(push (list :keyword
					    (c::arg-info-keyword info)
					    (frob final-arg debug-vars))
				      res))
			       (:rest
				(push (list :rest (frob final-arg debug-vars))
				      res))
			       (:optional
				(push (list :optional
					    (frob final-arg debug-vars))
				      res)))
			     (when (c::arg-info-supplied-p info)
			       (nconc
				(car res)
				(list (frob (pop final-args) debug-vars)))))
			    (t
			     (push (frob final-arg debug-vars) res)))))
		  (setf (debug-function-%lambda-list debug-function)
			(nreverse res)))
		;;
		;; All required args, so return them in a list.
		(dolist (v (c::lambda-vars ir1-lambda)
			   (setf (debug-function-%lambda-list debug-function)
				 (nreverse res)))
		  (push (frob v debug-vars) res)))))
	;;
	;; Everything's unparsed and cached, so return it.
	lambda-list)))

;;; COMPILED-DEBUG-FUNCTION-LAMBDA-LIST -- Internal.
;;;
;;; If this has to compute the lambda list, it caches it in debug-function.
;;;
(defun compiled-debug-function-lambda-list (debug-function)
  (let ((lambda-list (debug-function-%lambda-list debug-function)))
    (cond ((eq lambda-list :unparsed)
	   (multiple-value-bind
	       (args argsp)
	       (parse-compiled-debug-function-lambda-list debug-function)
	     (setf (debug-function-%lambda-list debug-function) args)
	     (if argsp
		 args
		 (debug-signal 'lambda-list-unavailable
			       :debug-function debug-function))))
	  (lambda-list)
	  ((bogus-debug-function-p debug-function)
	   nil)
	  ((c::compiled-debug-function-arguments
	    (compiled-debug-function-compiler-debug-fun
	     debug-function))
	   ;; If the packed information is there (whether empty or not) as
	   ;; opposed to being nil, then returned our cached value (nil).
	   nil)
	  (t
	   ;; Our cached value is nil, and the packed lambda-list information
	   ;; is nil, so we don't have anything available.
	   (debug-signal 'lambda-list-unavailable
			 :debug-function debug-function)))))

;;; PARSE-COMPILED-DEBUG-FUNCTION-LAMBDA-LIST -- Internal.
;;;
;;; COMPILED-DEBUG-FUNCTION-LAMBDA-LIST calls this when a
;;; compiled-debug-function has no lambda-list information cached.  It returns
;;; the lambda-list as the first value and whether there was any argument
;;; information as the second value.  Therefore, nil and t means there were no
;;; arguments, but nil and nil means there was no argument information.
;;;
(defun parse-compiled-debug-function-lambda-list (debug-function)
  (let ((args (c::compiled-debug-function-arguments
	       (compiled-debug-function-compiler-debug-fun
		debug-function))))
    (declare (type (or (simple-array * (*)) null) args))
    (if (not args)
	(values nil nil)
	(let ((vars (debug-function-debug-variables debug-function))
	      (i 0)
	      (len (length args))
	      (res nil))
	  (declare (type (or null simple-vector) vars))
	  (loop
	    (when (>= i len) (return))
	    (let ((ele (aref args i)))
	      (if (symbolp ele)
		  (case ele
		    (c::deleted
		     ;; Deleted required arg at beginning of args array.
		     (push :deleted res))
		    (c::optional-args
		     ;; When I fill this in, I can remove the (typep last 'cons)
		     ;; below.
		     )
		    (c::supplied-p
		     ;; supplied-p var immediately following keyword or optional.
		     ;; Stick the extra var in the result element representing
		     ;; the keyword or optional.
		     ;; ACTUALLY, WE DON'T HANDLE OPTIONALS CORRECTLY YET. ???
		     (let ((last (car res))
			   (v (compiled-debug-function-lambda-list-var
			       args (incf i) vars)))
		       (if (typep last 'cons)
			   (nconc last (list v))
			   (setf (car res) (list :optional last v)))))
		    (c::rest-arg
		     (push (list :rest
				 (compiled-debug-function-lambda-list-var
				  args (incf i) vars))
			   res))
		    (c::more-arg
		     (error "I thought I'd never see a more-arg?"))
		    (t
		     ;; Keyword arg.
		     (push (list :keyword
				 ele
				 (compiled-debug-function-lambda-list-var
				  args (incf i) vars))
			   res)))
		  ;; Required arg at beginning of args array.
		  (push (svref vars ele) res)))
	    (incf i))
	  (values (nreverse res) t)))))

;;; COMPILED-DEBUG-FUNCTION-LAMBDA-LIST-VAR -- Internal
;;;
;;; Used in COMPILED-DEBUG-FUNCTION-LAMBDA-LIST.
;;;
(defun compiled-debug-function-lambda-list-var (args i vars)
  (declare (type (simple-array * (*)) args)
	   (simple-vector vars))
  (let ((ele (aref args i)))
    (cond ((not (symbolp ele)) (svref vars ele))
	  ((eq ele 'c::deleted) :deleted)
	  (t (error "Malformed arguments description.")))))

;;; COMPILED-DEBUG-FUNCTION-DEBUG-INFO -- Internal.
;;;
(defun compiled-debug-function-debug-info (debug-fun)
  (code-debug-info (compiled-debug-function-component debug-fun)))


;;;; Unpacking variable and basic block data.

(defvar *parsing-buffer*
  (make-array 20 :adjustable t :fill-pointer t))
(defvar *other-parsing-buffer*
  (make-array 20 :adjustable t :fill-pointer t))
;;;
;;; WITH-PARSING-BUFFER -- Internal.
;;;
;;; PARSE-DEBUG-BLOCKS and PARSE-DEBUG-VARIABLES use this to unpack binary
;;; encoded information.  It returns the values returned by the last form
;;; in body.
;;;
;;; This binds buffer-var to *parsing-buffer*, makes sure it starts at element
;;; zero, and makes sure if we unwind, we nil out any set elements for GC
;;; purposes.
;;;
;;; This also binds other-var to *other-parsing-buffer* when it is supplied,
;;; making sure it starts at element zero and that we nil out any elements if
;;; we unwind.
;;;
;;; This defines the local macro RESULT that takes a buffer, copies its
;;; elements to a resulting simple-vector, nil's out elements, and restarts
;;; the buffer at element zero.  RESULT returns the simple-vector.
;;;
(eval-when (compile eval)
(defmacro with-parsing-buffer ((buffer-var &optional other-var) &body body)
  (let ((len (gensym))
	(res (gensym)))
    `(unwind-protect
	 (let ((,buffer-var *parsing-buffer*)
	       ,@(if other-var `((,other-var *other-parsing-buffer*))))
	   (setf (fill-pointer ,buffer-var) 0)
	   ,@(if other-var `((setf (fill-pointer ,other-var) 0)))
	   (macrolet ((result (buf)
			`(let* ((,',len (length ,buf))
				(,',res (make-array ,',len)))
			   (replace ,',res ,buf :end1 ,',len :end2 ,',len)
			   (fill ,buf nil :end ,',len)
			   (setf (fill-pointer ,buf) 0)
			   ,',res)))
	     ,@body))
     (fill *parsing-buffer* nil)
     ,@(if other-var `((fill *other-parsing-buffer* nil))))))
) ;eval-when


;;; DEBUG-FUNCTION-DEBUG-BLOCKS -- Internal.
;;;
;;; The argument is a debug internals structure.  This returns the debug-blocks
;;; for debug-function, regardless of whether we have unpacked them yet.  It
;;; signals a no-debug-blocks condition if it can't return the blocks.
;;;
(defun debug-function-debug-blocks (debug-function)
  (let ((blocks (debug-function-blocks debug-function)))
    (cond ((eq blocks :unparsed)
	   (setf (debug-function-blocks debug-function)
		 (parse-debug-blocks debug-function))
	   (unless (debug-function-blocks debug-function)
	     (debug-signal 'no-debug-blocks
			   :debug-function debug-function))
	   (debug-function-blocks debug-function))
	  (blocks)
	  (t
	   (debug-signal 'no-debug-blocks
			 :debug-function debug-function)))))

;;; PARSE-DEBUG-BLOCKS -- Internal.
;;;
;;; This returns a simple-vector of debug-blocks or nil.  Nil indicates there
;;; was no basic block information.
;;;
(defun parse-debug-blocks (debug-function)
  (etypecase debug-function
    (compiled-debug-function
     (parse-compiled-debug-blocks debug-function))
    (bogus-debug-function
     (debug-signal 'no-debug-blocks :debug-function debug-function))
    (interpreted-debug-block
     (parse-interpreted-debug-blocks debug-function))))


;;; PARSE-COMPILED-DEBUG-BLOCKS -- Internal.
;;;
;;; This does some of the work of PARSE-DEBUG-BLOCKS.
;;;
(defun parse-compiled-debug-blocks (debug-function)
  (let* ((debug-fun (compiled-debug-function-compiler-debug-fun debug-function))
	 (var-count (length (debug-function-debug-variables debug-function)))
	 (blocks (c::compiled-debug-function-blocks debug-fun))
	 ;; 8 is a hard-wired constant in the compiler for the element size of
	 ;; the packed binary representation of the blocks data.
	 (live-set-len (ceiling var-count 8))
	 (tlf-number (c::compiled-debug-function-tlf-number debug-fun)))
    (unless blocks (return-from parse-compiled-debug-blocks nil))
    (macrolet ((aref+ (a i) `(prog1 (aref ,a ,i) (incf ,i))))
      (with-parsing-buffer (blocks-buffer locations-buffer)
	(let ((i 0)
	      (len (length blocks))
	      (last-pc 0))
	  (loop
	    (when (>= i len) (return))
	    (let ((succ-and-flags (aref+ blocks i))
		  (successors nil))
	      (declare (type (unsigned-byte 8) succ-and-flags)
		       (list successors))
	      (dotimes (k (ldb c::compiled-debug-block-nsucc-byte
			       succ-and-flags))
		(push (c::read-var-integer blocks i) successors))
	      (let* ((locations
		      (dotimes (k (c::read-var-integer blocks i)
				  (result locations-buffer))
			(let ((kind (svref c::compiled-code-location-kinds
					   (aref+ blocks i)))
			      (pc (+ last-pc (c::read-var-integer blocks i)))
			      (tlf-offset (or tlf-number
					      (c::read-var-integer blocks i)))
			      (form-number (c::read-var-integer blocks i))
			      (live-set (c::read-packed-bit-vector
					 live-set-len blocks i)))
			  (vector-push-extend (make-compiled-code-location
					       pc debug-function tlf-offset
					       form-number live-set kind)
					      locations-buffer)
			  (setf last-pc pc))))
		     (block (make-compiled-debug-block
			     locations successors
			     (not (zerop (logand
					  c::compiled-debug-block-elsewhere-p
					  succ-and-flags))))))
		(vector-push-extend block blocks-buffer)
		(dotimes (k (length locations))
		  (setf (code-location-%debug-block (svref locations k))
			block))))))
	(let ((res (result blocks-buffer)))
	  (declare (simple-vector res))
	  (dotimes (i (length res))
	    (let* ((block (svref res i))
		   (succs nil))
	      (dolist (ele (debug-block-successors block))
		(push (svref res ele) succs))
	      (setf (debug-block-successors block) succs)))
	  res)))))

;;; PARSE-INTERPRETED-DEBUG-BLOCKS -- Internal.
;;;
;;; This does some of the work of PARSE-DEBUG-BLOCKS.
;;;
(defun parse-interpreted-debug-blocks (debug-function)
  (let ((ir1-lambda (interpreted-debug-function-ir1-lambda debug-function)))
    (with-parsing-buffer (buffer)
      (c::do-blocks (block (c::block-component
			    (c::node-block (c::lambda-bind ir1-lambda))))
	(when (eq ir1-lambda (c::block-home-lambda block))
	  (vector-push-extend (make-interpreted-debug-block block) buffer)))
      (result buffer))))


;;; DEBUG-FUNCTION-DEBUG-VARIABLES -- Internal.
;;;
;;; The argument is a debug internals structure.  This returns nil if there is
;;; no variable information.  It returns an empty simple-vector if there were
;;; no locals in the function.  Otherwise it returns a simple-vector of
;;; debug-variables.
;;;
(defun debug-function-debug-variables (debug-function)
  (let ((vars (debug-function-debug-vars debug-function)))
    (if (eq vars :unparsed)
	(setf (debug-function-debug-vars debug-function)
	      (etypecase debug-function
		(compiled-debug-function
		 (parse-compiled-debug-variables debug-function))
		(bogus-debug-function nil)
		(interpreted-debug-function
		 (parse-interpreted-debug-variables debug-function))))
	vars)))


;;; PARSE-INTERPRETED-DEBUG-VARIABLES -- Internal.
;;;
;;; This grabs all the variables from debug-fun's ir1-lambda, from the IR1
;;; lambda vars, and all of it's LET's.  Each LET is an IR1 lambda.  For each
;;; variable, we make an interpreted-debug-variable.  We then SORT all the
;;; variables by name.  Then we go through, and for any duplicated names we
;;; distinguish the interpreted-debug-variables by setting their id slots to a
;;; distinct number.
;;;
(defun parse-interpreted-debug-variables (debug-fun)
  (let* ((ir1-lambda (interpreted-debug-function-ir1-lambda debug-fun))
	 (vars (flet ((frob (ir1-lambda buf)
			(dolist (v (c::lambda-vars ir1-lambda))
			  (vector-push-extend
			   (let* ((id (c::leaf-name v))
				  (pkg (symbol-package id)))
			     (make-interpreted-debug-variable
			      (symbol-name id)
			      (when pkg (package-name pkg))
			      v))
			   buf))))
		 (with-parsing-buffer (buf)
		   (frob ir1-lambda buf)
		   (dolist (let-lambda (c::lambda-lets ir1-lambda))
		     (frob let-lambda buf))
		   (result buf)))))
    (declare (simple-vector vars))
    (sort vars #'string< :key #'debug-variable-name)
    (let ((len (length vars)))
      (when (> len 1)
	(let ((i 0)
	      (j 1))
	  (block PUNT
	    (loop
	      (let* ((var-i (svref vars i))
		     (var-j (svref vars j))
		     (name (debug-variable-name var-i)))
		(when (string= name (debug-variable-name var-j))
		  (let ((count 1))
		    (loop 
		      (setf (debug-variable-id var-j) count)
		      (when (= (incf j) len) (return-from PUNT))
		      (setf var-j (svref vars j))
		      (when (string/= name (debug-variable-name var-j))
			(return))
		      (incf count))))
		(setf i j)
		(incf j)
		(when (= j len) (return))))))))
    vars))

;;; PARSE-COMPILED-DEBUG-VARIABLES -- Internal.
;;;
;;; This parses the packed binary representation of debug-variables from
;;; debug-function's c::compiled-debug-function.
;;;
(defun parse-compiled-debug-variables (debug-function)
  (let* ((debug-fun (compiled-debug-function-compiler-debug-fun debug-function))
	 (packed-vars (c::compiled-debug-function-variables debug-fun))
	 (default-package (c::compiled-debug-info-package
			   (compiled-debug-function-debug-info debug-function))))
    (unless packed-vars
      (return-from parse-compiled-debug-variables nil))
    (when (zerop (length packed-vars))
      ;; Return a simple-vector not whatever packed-vars may be.
      (return-from parse-compiled-debug-variables '#()))
    (let ((i 0)
	  (len (length packed-vars)))
      (with-parsing-buffer (buffer)
	(loop
	  (let ((flags (aref packed-vars i)))
	    (declare (type (unsigned-byte 8) flags))
	    (incf i)
	    ;; The routines in the "C" package are macros that advance the index.
	    (let ((name (c::read-var-string packed-vars i))
		  (package (cond ((not
				   (zerop
				    (logand c::compiled-debug-variable-packaged
					    flags)))
				  (c::read-var-string packed-vars i))
				 ((zerop
				   (logand c::compiled-debug-variable-uninterned
					   flags))
				  default-package)
				 (t nil)))
		  (id (if (zerop (logand c::compiled-debug-variable-id-p
					 flags))
			  0
			  (c::read-var-integer packed-vars i)))
		  (sc-offset (c::read-var-integer packed-vars i))
		  (save-sc-offset (if (zerop
				       (logand
					c::compiled-debug-variable-save-loc-p
					flags))
				      nil
				      (c::read-var-integer packed-vars i))))
	      (vector-push-extend
	       (make-compiled-debug-variable
		name package id
		(not (zerop (logand c::compiled-debug-variable-environment-live
				    flags)))
		sc-offset save-sc-offset)
	       buffer)))
	  (when (>= i len) (return)))
	(result buffer)))))



;;;; Code-locations.

;;; CODE-LOCATION-UNKNOWN-P -- Public.
;;;
;;; If we're sure of whether code-location is known, return t or nil.  If we're
;;; :unsure, then try to fill in the code-location's slots.  This determines
;;; whether there is any debug-block information, and if code-location is
;;; known.
;;;
;;; ??? IF this conses closures every time it's called, then break off the
;;; :unsure part to get the HANDLER-CASE into another function.
;;;
(defun code-location-unknown-p (basic-code-location)
  "Returns whether basic-code-location is unknown.  It returns nil when the
   code-location is known."
  (ecase (code-location-%unknown-p basic-code-location)
    ((t) t)
    ((nil) nil)
    (:unsure
     (setf (code-location-%unknown-p basic-code-location)
	   (handler-case (not (fill-in-code-location basic-code-location))
	     (no-debug-blocks () t))))))

;;; CODE-LOCATION-DEBUG-BLOCK -- Public.
;;;
(defun code-location-debug-block (basic-code-location)
  "Returns the debug-block containing code-location if it is available.  Some
   debug policies inhibit debug-block information, and if none is available,
   then this signals a no-debug-blocks condition."
  (let ((block (code-location-%debug-block basic-code-location)))
    (if (eq block :unparsed)
	(etypecase basic-code-location
	  (compiled-code-location
	   (compute-compiled-code-location-debug-block basic-code-location))
	  (interpreted-code-location
	   (setf (code-location-%debug-block basic-code-location)
		 (make-interpreted-debug-block
		  (c::node-block
		   (interpreted-code-location-ir1-node basic-code-location))))))
	block)))

;;; COMPUTE-COMPILED-CODE-LOCATION-DEBUG-BLOCK -- Internal.
;;;
;;; This stores and returns basic-code-location's debug-block.  It determines
;;; the correct one using the code-location's pc.  This uses
;;; DEBUG-FUNCTION-DEBUG-BLOCKS to return the cached block information or
;;; signal a 'no-debug-blocks condition.  The blocks are sorted by their first
;;; code-location's pc, in ascending order.  Therefore, as soon as we find a
;;; block that starts with a pc greater than basic-code-location's pc, we know
;;; the previous block contains the pc.  If we get to the last block, then the
;;; code-location is either in the second to last block or the last block, and
;;; we have to be careful in determining this since the last block could be
;;; random code at the end of the function.  We have to check for the last
;;; block being random code first to see how to compare the code-location's pc.
;;;
(defun compute-compiled-code-location-debug-block (basic-code-location)
  (let* ((pc (compiled-code-location-pc basic-code-location))
	 (debug-function (code-location-debug-function
			  basic-code-location))
	 (blocks (debug-function-debug-blocks debug-function))
	 (len (length blocks)))
    (declare (simple-vector blocks))
    (setf (code-location-%debug-block basic-code-location)
	  (if (= len 1)
	      (svref blocks 0)
	      (do ((i 1 (1+ i))
		   (end (1- len)))
		  ((= i end)
		   (let ((last (svref blocks end)))
		     (cond
		      ((debug-block-elsewhere-p last)
		       (if (< pc
			      (c::compiled-debug-function-elsewhere-pc
			       (compiled-debug-function-compiler-debug-fun
				debug-function)))
			   (svref blocks (1- end))
			   last))
		      ((< pc
			  (compiled-code-location-pc
			   (svref (compiled-debug-block-code-locations last)
				  0)))
		       (svref blocks (1- end)))
		      (t last))))
		(declare (type c::index i end))
		(when (< pc
			 (compiled-code-location-pc
			  (svref (compiled-debug-block-code-locations
				  (svref blocks i))
				 0)))
		  (return (svref blocks (1- i)))))))))

;;; CODE-LOCATION-DEBUG-SOURCE -- Public.
;;;
(defun code-location-debug-source (code-location)
  "Returns the code-location's debug-source."
  (etypecase code-location
    (compiled-code-location
     (let* ((info (compiled-debug-function-debug-info
		   (code-location-debug-function code-location)))
	    (sources (c::compiled-debug-info-source info))
	    (len (length sources)))
	 (declare (list sources))
	 (if (= len 1)
	     (car sources)
	     (do ((prev sources src)
		  (src (cdr sources) (cdr src))
		  (offset (code-location-top-level-form-offset code-location)))
		 ((null src) (car prev))
	       (when (< offset (c::debug-source-source-root (car src)))
		 (return (car prev)))))))
    (interpreted-code-location
     (first
      (let ((c::*lexical-environment* (c::make-null-environment)))
	(c::debug-source-for-info
	 (c::component-source-info
	  (c::block-component
	   (c::node-block
	    (interpreted-code-location-ir1-node code-location))))))))))


;;; CODE-LOCATION-TOP-LEVEL-FORM-OFFSET -- Public.
;;;
(defun code-location-top-level-form-offset (code-location)
  "Returns the number of top-level forms before the one containing
   code-location as seen by the compiler in some compilation unit.  A
   compilation unit is not necessarily a single file, see the section on
   debug-sources."
  (when (code-location-unknown-p code-location)
    (error 'unknown-code-location :code-location code-location))
  (let ((tlf-offset (code-location-%tlf-offset code-location)))
    (cond ((eq tlf-offset :unparsed)
	   (etypecase code-location
	     (compiled-code-location
	      (unless (fill-in-code-location code-location)
		;; This check should be unnecessary.  We're missing debug info
		;; the compiler should have dumped.
		(error "Unknown code location?  It should be known."))
	      (code-location-%tlf-offset code-location))
	     (interpreted-code-location
	      (setf (code-location-%tlf-offset code-location)
		    (c::source-path-tlf-number
		     (c::node-source-path
		      (interpreted-code-location-ir1-node code-location)))))))
	  (t tlf-offset))))

;;; CODE-LOCATION-FORM-NUMBER -- Public.
;;;
(defun code-location-form-number (code-location)
  "Returns the number of the form corresponding to code-location.  The form
   number is derived by a walking the subforms of a top-level form in
   depth-first order."
  (when (code-location-unknown-p code-location)
    (error 'unknown-code-location :code-location code-location))
  (let ((form-num (code-location-%form-number code-location)))
    (cond ((eq form-num :unparsed)
	   (etypecase code-location
	     (compiled-code-location
	      (unless (fill-in-code-location code-location)
		;; This check should be unnecessary.  We're missing debug info
		;; the compiler should have dumped.
		(error "Unknown code location?  It should be known."))
	      (code-location-%form-number code-location))
	     (interpreted-code-location
	      (setf (code-location-%form-number code-location)
		    (c::source-path-form-number
		     (c::node-source-path
		      (interpreted-code-location-ir1-node code-location)))))))
	  (t form-num))))

;;; COMPILED-CODE-LOCATION-LIVE-SET -- Internal.
;;;
;;; This returns the code-location's live-set if it is available.  If there
;;; is no debug-block information, this returns nil.
;;;
(defun compiled-code-location-live-set (code-location)
  (if (code-location-unknown-p code-location)
      nil
      (let ((live-set (compiled-code-location-%live-set code-location)))
	(cond ((eq live-set :unparsed)
	       (unless (fill-in-code-location code-location)
		 ;; This check should be unnecessary.  We're missing debug info
		 ;; the compiler should have dumped.
		 (error "Unknown code location?  It should be known."))
	       (compiled-code-location-%live-set code-location))
	      (t live-set)))))

;;; CODE-LOCATION= -- Public.
;;;
(defun code-location= (obj1 obj2)
  "Returns whether obj1 and obj2 are the same place in the code."
  (etypecase obj1
    (compiled-code-location
     (etypecase obj2
       (compiled-code-location
	(and (eq (code-location-debug-function obj1)
		 (code-location-debug-function obj2))
	     (sub-compiled-code-location= obj1 obj2)))
       (interpreted-code-location
	nil)))
    (interpreted-code-location
     (etypecase obj2
       (compiled-code-location
	nil)
       (interpreted-code-location
	(eq (interpreted-code-location-ir1-node obj1)
	    (interpreted-code-location-ir1-node obj2)))))))
;;;
(defun sub-compiled-code-location= (obj1 obj2)
  (= (compiled-code-location-pc obj1) (compiled-code-location-pc obj2)))

;;; FILL-IN-CODE-LOCATION -- Internal.
;;;
;;; This fills in location's :unparsed slots.  It returns t or nil depending on
;;; whether the code-location was known in its debug-function's debug-block
;;; information.  This may signal a no-debug-blocks condition due to
;;; DEBUG-FUNCTION-DEBUG-BLOCKS, and it assumes the %unknown-p slot is already
;;; set or going to be set.
;;;
(defun fill-in-code-location (code-location)
  (let* ((debug-function (code-location-debug-function code-location))
	 (blocks (debug-function-debug-blocks debug-function)))
    (declare (simple-vector blocks))
    (dotimes (i (length blocks) nil)
      (let* ((block (svref blocks i))
	     (locations (compiled-debug-block-code-locations block)))
	(declare (simple-vector locations))
	(dotimes (j (length locations))
	  (let ((loc (svref locations j)))
	    (when (sub-compiled-code-location= code-location loc)
	      (setf (code-location-%debug-block code-location) block)
	      (setf (code-location-%tlf-offset code-location)
		    (code-location-%tlf-offset loc))
	      (setf (code-location-%form-number code-location)
		    (code-location-%form-number loc))
	      (setf (compiled-code-location-%live-set code-location)
		    (compiled-code-location-%live-set loc))
	      (setf (compiled-code-location-kind code-location)
		    (compiled-code-location-kind loc))
	      (return-from fill-in-code-location t))))))))



;;;; Debug-blocks.

;;; DO-DEBUG-BLOCK-LOCATIONS -- Public.
;;;
(defmacro do-debug-block-locations ((code-var debug-block &optional return)
				    &body body)
  "Executes forms in a context with code-var bound to each code-location in
   debug-block.  This returns the value of executing result (defaults to nil)."
  (let ((code-locations (gensym))
	(i (gensym)))
    `(let ((,code-locations (debug-block-code-locations ,debug-block)))
       (declare (simple-vector ,code-locations))
       (dotimes (,i (length ,code-locations) ,return)
	 (let ((,code-var (svref ,code-locations ,i)))
	   ,@body)))))

;;; DEBUG-BLOCK-FUNCTION-NAME -- Internal.
;;;
(defun debug-block-function-name (debug-block)
  "Returns the name of the function represented by debug-function.  This may
   be a string or a cons; do not assume it is a symbol."
  (etypecase debug-block
    (compiled-debug-block
     (let ((code-locs (compiled-debug-block-code-locations debug-block)))
       (declare (simple-vector code-locs))
       (if (zerop (length code-locs))
	   "??? Can't get name of debug-block's function."
	   (debug-function-name
	    (code-location-debug-function (svref code-locs 0))))))
    (interpreted-debug-block
     (c::lambda-name (c::block-home-lambda
		      (interpreted-debug-block-ir1-block debug-block))))))


;;; DEBUG-BLOCK-CODE-LOCATIONS -- Internal.
;;;
(defun debug-block-code-locations (debug-block)
  (etypecase debug-block
    (compiled-debug-block
     (compiled-debug-block-code-locations debug-block))
    (interpreted-debug-block
     (interpreted-debug-block-code-locations debug-block))))

;;; INTERPRETED-DEBUG-BLOCK-CODE-LOCATIONS -- Internal.
;;;
(defun interpreted-debug-block-code-locations (debug-block)
  (let ((code-locs (interpreted-debug-block-locations debug-block)))
    (if (eq code-locs :unparsed)
	(with-parsing-buffer (buf)
	  (c::do-nodes (node cont (interpreted-debug-block-ir1-block
				   debug-block))
	    (vector-push-extend (make-interpreted-code-location
				 node
				 (make-interpreted-debug-function
				  (c::block-home-lambda (c::node-block node))))
				buf))
	  (setf (interpreted-debug-block-locations debug-block)
		(result buf)))
	code-locs)))



;;;; Variables.

;;; DEBUG-VARIABLE-SYMBOL -- Public.
;;;
(defun debug-variable-symbol (debug-var)
  "Returns the symbol from interning DEBUG-VARIABLE-NAME in the package named
   by DEBUG-VARIABLE-PACKAGE."
  (let ((package (debug-variable-package debug-var)))
    (if package
	(intern (debug-variable-name debug-var) package)
	(make-symbol (debug-variable-name debug-var)))))

;;; DEBUG-VARIABLE-VALID-VALUE -- Public.
;;;
(defun debug-variable-valid-value (debug-var frame)
  "Returns the value stored for debug-variable in frame.  If the value is not
   :valid, then this signals an invalid-value error."
  (unless (eq (debug-variable-validity debug-var (frame-code-location frame))
	      :valid)
    (error 'invalid-value :debug-variable debug-var :frame frame))
  (debug-variable-value debug-var frame))

;;; DEBUG-VARIABLE-VALUE -- Public.
;;;
(defun debug-variable-value (debug-var frame)
  "Returns the value stored for debug-variable in frame.  The value may be
   invalid."
  (etypecase debug-var
    (compiled-debug-variable
     (check-type frame compiled-frame)
     (let ((res (access-compiled-debug-var-slot debug-var frame)))
       (if (indirect-value-cell-p res)
	   (system:%primitive c::value-cell-ref res)
	   res)))
    (interpreted-debug-variable
     (check-type frame interpreted-frame)
     (eval::leaf-value-lambda-var
      (interpreted-code-location-ir1-node (frame-code-location frame))
      (interpreted-debug-variable-ir1-var debug-var)
      (frame-pointer frame)
      (interpreted-frame-closure frame)))))


;;; ACCESS-COMPILED-DEBUG-VAR-SLOT -- Internal.
;;;
;;; This returns what is stored for the variable represented by debug-var
;;; relative to the frame.  This may be an indirect value cell if the
;;; variable is both closed over and set.
;;;
(defun access-compiled-debug-var-slot (debug-var frame)
  (let ((escaped (compiled-frame-escaped frame)))
    (if escaped
	(sub-access-debug-var-slot
	 (frame-pointer frame)
	 (compiled-debug-variable-sc-offset debug-var)
	 escaped)
	(sub-access-debug-var-slot
	 (frame-pointer frame)
	 (or (compiled-debug-variable-save-sc-offset debug-var)
	     (compiled-debug-variable-sc-offset debug-var))))))

;;; SUB-ACCESS-DEBUG-VAR-SLOT -- Internal.
;;;
(defun sub-access-debug-var-slot (fp sc-offset &optional escaped)
  (macrolet ((with-escaped-value ((var) &body forms)
	       `(if escaped
		    (let ((,var (escape-register
				 escaped
				 (c::sc-offset-offset sc-offset))))
		      ,@forms)
		    :invalid-value-for-unescaped-register-storage))
	     (escaped-float-value (format)
	       `(if escaped
		    (escape-float-register escaped
					   (c::sc-offset-offset sc-offset)
					   ',format)
		    :invalid-value-for-unescaped-register-storage))
	     (with-nfp ((var) &body body)
	       `(let ((,var (if escaped
				(int-sap (escape-register escaped
							  c::nfp-offset))
				(sap-ref-sap fp c::nfp-save-offset))))
		  ,@body)))
    (ecase (c::sc-offset-scn sc-offset)
      ((#.vm:any-reg-sc-number #.vm:descriptor-reg-sc-number)
       (system:without-gcing
	(with-escaped-value (val)
	  (make-lisp-obj val))))
      (#.vm:base-character-reg-sc-number
       (with-escaped-value (val)
	 (code-char val)))
      (#.vm:sap-reg-sc-number
       (with-escaped-value (val)
	 (int-sap val)))
      (#.vm:signed-reg-sc-number
       (with-escaped-value (val)
	 (if (logbitp (1- vm:word-bits) val)
	     (logior val (ash -1 vm:word-bits))
	     val)))
      (#.vm:unsigned-reg-sc-number
       (with-escaped-value (val)
	 val))
      (#.vm:non-descriptor-reg-sc-number
       (error "Local non-descriptor register access?"))
      (#.vm:interior-reg-sc-number
       (error "Local interior register access?"))
      (#.vm:single-reg-sc-number
       (escaped-float-value single-float))
      (#.vm:double-reg-sc-number
       (escaped-float-value double-float))
      (#.vm:single-stack-sc-number
       (with-nfp (nfp)
	 (sap-ref-single nfp (vm::sc-offset-offset sc-offset))))
      (#.vm:double-stack-sc-number
       (with-nfp (nfp)
	 (sap-ref-double nfp (c::sc-offset-offset sc-offset))))
      (#.vm:control-stack-sc-number
       (stack-ref fp (c::sc-offset-offset sc-offset)))
      (#.vm:base-character-stack-sc-number
       (with-nfp (nfp)
	 (code-char (sap-ref-32 nfp (c::sc-offset-offset sc-offset)))))
      (#.vm:unsigned-stack-sc-number
       (with-nfp (nfp)
	 (sap-ref-32 nfp (c::sc-offset-offset sc-offset))))
      (#.vm:signed-stack-sc-number
       (with-nfp (nfp)
	 (signed-sap-ref-32 nfp (c::sc-offset-offset sc-offset))))
      (#.vm:sap-stack-sc-number
       (with-nfp (nfp)
	 (sap-ref-sap nfp (c::sc-offset-offset sc-offset)))))))


;;; %SET-DEBUG-VARIABLE-VALUE -- Internal.
;;;
;;; This stores value as the value of debug-var in frame.  In the
;;; compiled-debug-variable case, access the current value to determine if it
;;; is an indirect value cell.  This occurs when the variable is both closed
;;; over and set.  For interpreted-debug-variables just call
;;; EVAL::SET-LEAF-VALUE-LAMBDA-VAR with the right interpreter objects.
;;;
(defun %set-debug-variable-value (debug-var frame value)
  (etypecase debug-var
    (compiled-debug-variable
     (check-type frame compiled-frame)
     (let ((current-value (access-compiled-debug-var-slot debug-var frame)))
       (if (indirect-value-cell-p current-value)
	   (system:%primitive c::value-cell-set current-value value)
	   (set-compiled-debug-variable-slot debug-var frame value))))
    (interpreted-debug-variable
     (check-type frame interpreted-frame)
     (eval::set-leaf-value-lambda-var
      (interpreted-code-location-ir1-node (frame-code-location frame))
      (interpreted-debug-variable-ir1-var debug-var)
      (frame-pointer frame)
      (interpreted-frame-closure frame)
      value)))
  value)
;;;
(defsetf debug-variable-value %set-debug-variable-value)

;;; SET-COMPILED-DEBUG-VARIABLE-SLOT -- Internal.
;;;
;;; This stores value for the variable represented by debug-var relative to the
;;; frame.  This assumes the location directly contains the variable's value;
;;; that is, there is no indirect value cell currently there in case the
;;; variable is both closed over and set.
;;;
(defun set-compiled-debug-variable-slot (debug-var frame value)
  (let ((escaped (compiled-frame-escaped frame)))
    (if escaped
	(sub-set-debug-var-slot (frame-pointer frame)
				(compiled-debug-variable-sc-offset debug-var)
				value escaped)
	(sub-set-debug-var-slot
	 (frame-pointer frame)
	 (or (compiled-debug-variable-save-sc-offset debug-var)
	     (compiled-debug-variable-sc-offset debug-var))
	 value))))

;;; SUB-SET-DEBUG-VAR-SLOT -- Internal.
;;;
(defun sub-set-debug-var-slot (fp sc-offset value &optional escaped)
  (macrolet ((set-escaped-value (val)
	       `(if escaped
		    (setf (escape-register escaped
					   (c::sc-offset-offset sc-offset))
			  ,val)
		    value))
	     (set-escaped-float-value (format val)
	       `(if escaped
		    (setf (escape-float-register
			   escaped
			   (c::sc-offset-offset sc-offset)
			   ',format)
			  ,val)
		    value))
	     (with-nfp ((var) &body body)
	       `(let ((,var (if escaped
				(int-sap (escape-register escaped
							  vm::nfp-offset))
				(sap-ref-sap fp vm::nfp-save-offset))))
		  ,@body)))
    (ecase (c::sc-offset-scn sc-offset)
      ((#.vm:any-reg-sc-number #.vm:descriptor-reg-sc-number)
       (system:without-gcing
	(set-escaped-value
	  (get-lisp-obj-address value))))
      (#.vm:base-character-reg-sc-number
       (set-escaped-value (char-code value)))
      (#.vm:sap-reg-sc-number
       (set-escaped-value (sap-int value)))
      (#.vm:signed-reg-sc-number
       (set-escaped-value (logand value (1- (ash 1 vm:word-bits)))))
      (#.vm:unsigned-reg-sc-number
       (set-escaped-value value))
      (#.vm:non-descriptor-reg-sc-number
       (error "Local non-descriptor register access?"))
      (#.vm:interior-reg-sc-number
       (error "Local interior register access?"))
      (#.vm:single-reg-sc-number
       (set-escaped-float-value single-float value))
      (#.vm:double-reg-sc-number
       (set-escaped-float-value double-float value))
      (#.vm:single-stack-sc-number
       (with-nfp (nfp)
	 (setf (sap-ref-single nfp (c::sc-offset-offset sc-offset))
	       (the single-float value))))
      (#.vm:double-stack-sc-number
       (with-nfp (nfp)
	 (setf (sap-ref-double nfp (c::sc-offset-offset sc-offset))
	       (the double-float value))))
      (#.vm:control-stack-sc-number
       (setf (stack-ref fp (c::sc-offset-offset sc-offset)) value))
      (#.vm:base-character-stack-sc-number
       (with-nfp (nfp)
	 (setf (sap-ref-32 nfp (c::sc-offset-offset sc-offset))
	       (char-code (the character value)))))
      (#.vm:unsigned-stack-sc-number
       (with-nfp (nfp)
	 (setf (sap-ref-32 nfp (c::sc-offset-offset sc-offset))
	       (the (unsigned-byte 32) value))))
      (#.vm:signed-stack-sc-number
       (with-nfp (nfp)
	 (setf (signed-sap-ref-32 nfp (c::sc-offset-offset sc-offset))
	       (the (signed-byte 32) value))))
      (#.vm:sap-stack-sc-number
       (with-nfp (nfp)
	 (setf (sap-ref-sap nfp (c::sc-offset-offset sc-offset))
	       (the system-area-pointer value)))))))

(defsetf debug-variable-value %set-debug-variable-value)


;;; INDIRECT-VALUE-CELL-P -- Internal.
;;;
;;; The method for setting and accessing compiled-debug-variable values use
;;; this to determine if the value stored is the actual value or an indirection
;;; cell.
;;;
(defun indirect-value-cell-p (x)
  (and (= (get-lowtag x) vm:other-pointer-type)
       (= (get-type x) vm:value-cell-header-type)))


;;; DEBUG-VARIABLE-VALIDITY -- Public.
;;;
;;; If the variable is always alive, then it is valid.  If the code-location is
;;; unknown, then the variable's validity is :unknown.  Once we've called
;;; CODE-LOCATION-UNKNOWN-P, we know the live-set information has been cached
;;; in the code-location.
;;;
(defun debug-variable-validity (debug-var basic-code-loc)
  "Returns three values reflecting the validity of debug-variable's value
   at basic-code-location:
      :valid    The value is known to be available.
      :invalid  The value is known to be unavailable.
      :unknown  The value's availability is unknown."
  (etypecase debug-var
    (compiled-debug-variable
     (compiled-debug-variable-validity debug-var basic-code-loc))
    (interpreted-debug-variable
     (check-type basic-code-loc interpreted-code-location)
     (let ((validp (rassoc (interpreted-debug-variable-ir1-var debug-var)
			   (c::lexenv-variables
			    (c::node-lexenv
			     (interpreted-code-location-ir1-node
			      basic-code-loc))))))
       (if validp :valid :invalid)))))

;;; COMPILED-DEBUG-VARIABLE-VALIDITY -- Internal.
;;;
;;; This is the method for DEBUG-VARIABLE-VALIDITY for compiled-debug-variables.
;;; For safety, make sure basic-code-loc is what we think.
;;;
(defun compiled-debug-variable-validity (debug-var basic-code-loc)
  (check-type basic-code-loc compiled-code-location)
  (cond ((debug-variable-alive-p debug-var)
	 (let ((debug-fun (code-location-debug-function basic-code-loc)))
	   (if (>= (compiled-code-location-pc basic-code-loc)
		   (c::compiled-debug-function-start-pc
		    (compiled-debug-function-compiler-debug-fun debug-fun)))
	       :valid
	       :invalid)))
	((code-location-unknown-p basic-code-loc) :unknown)
	(t
	 (let ((pos (position debug-var
			      (debug-function-debug-variables
			       (code-location-debug-function basic-code-loc)))))
	   (unless pos
	     (error 'unknown-debug-variable
		    :debug-variable debug-var
		    :debug-function
		    (code-location-debug-function basic-code-loc)))
	   ;; There must be live-set info since basic-code-loc is known.
	   (if (zerop (sbit (compiled-code-location-live-set basic-code-loc)
			    pos))
	       :invalid
	       :valid)))))



;;;; Sources.

;;; Written by Rob Maclachlan.
;;; Documented by Bill Chiles.
;;;
;;; This code produces and uses what we call source-paths.  A source-path is a
;;; list whose first element is a form number as returned by
;;; CODE-LOCATION-FORM-NUMBER and whose last element is a top-level-form number
;;; as returned by CODE-LOCATION-TOP-LEVEL-FORM-NUMBER.  The elements from the
;;; last to the first, exclusively, are the numbered subforms into which to
;;; descend.  For example:
;;;    (defun foo (x)
;;;      (let ((a (aref x 3)))
;;;        (cons a 3)))
;;; The call to AREF in this example is form number 5.  Assuming this DEFUN is
;;; the 11'th top-level-form, the source-path for the AREF call is as follows:
;;;    (5 1 0 1 3 11)
;;; Given the DEFUN, 3 gets you the LET, 1 gets you the bindings, 0 gets the
;;; first binding, and 1 gets the AREF form.
;;;


;;; Temporary buffer used to build form-number => source-path translation in
;;; FORM-NUMBER-TRANSLATIONS.
;;;
(defvar *form-number-temp* (make-array 10 :fill-pointer 0 :adjustable t))

;;; Table used to detect CAR circularities in FORM-NUMBER-TRANSLATIONS.
;;;
(defvar *form-number-circularity-table* (make-hash-table :test #'eq))

;;; FORM-NUMBER-TRANSLATIONS  --  Public.
;;;
;;; The vector elements are in the same format as the compiler's
;;; NODE-SOUCE-PATH; that is, the first element is the form number and the last
;;; is the top-level-form number.
;;;
(defun form-number-translations (form tlf-number)
  "This returns a table mapping form numbers to source-paths.  A source-path
   indicates a descent into the top-level-form form, going directly to the
   subform corressponding to the form number."
  (clrhash *form-number-circularity-table*)
  (setf (fill-pointer *form-number-temp*) 0)
  (sub-translate-form-numbers form (list tlf-number))
  (coerce *form-number-temp* 'simple-vector))
;;;
(defun sub-translate-form-numbers (form path)
  (unless (gethash form *form-number-circularity-table*)
    (setf (gethash form *form-number-circularity-table*) t)
    (vector-push-extend (cons (fill-pointer *form-number-temp*) path)
			*form-number-temp*)
    (let ((pos 0)
	  (subform form)
	  (trail form))
      (declare (fixnum pos))
      (macrolet ((frob ()
		   '(progn
		      (when (atom subform) (return))
		      (let ((fm (car subform)))
			(when (consp fm)
			  (sub-translate-form-numbers fm (cons pos path)))
			(incf pos))
		      (setq subform (cdr subform))
		      (when (eq subform trail) (return)))))
	(loop
	  (frob)
	  (frob)
	  (setq trail (cdr trail)))))))


;;; SOURCE-PATH-CONTEXT  --  Public.
;;;
(defun source-path-context (form path context)
  "Form is a top-level form, and path is a source-path into it.  This returns
   the form indicated by the source-path.  Context is the number of enclosing
   forms to return instead of directly returning the source-path form.  When
   context is non-zero, the form returned contains a marker, #:****HERE****,
   immediately before the form indicated by path."
  (declare (type unsigned-byte context))
  ;;
  ;; Get to the form indicated by path or the enclosing form indicated by
  ;; context and path.
  (let ((path (nreverse (butlast (cdr path)))))
    (dotimes (i (- (length path) context))
      (setq form (elt form (first path)))
      (setq path (rest path)))
    ;;
    ;; Recursively rebuild the source form resulting from the above descent,
    ;; copying the beginning of each subform up to the next subform we descend
    ;; into according to path.  At the bottom of the recursion, we return the
    ;; form indicated by path preceded by our marker, and this gets spliced
    ;; into the resulting list structure on the way back up.
    (labels ((frob (form path level)
	       (if (or (zerop level) (null path))
		   (if (zerop context)
		       form
		       `(#:***here*** ,form))
		   (let* ((n (first path))
			  (res (frob (elt form n) (rest path) (1- level))))
		     (nconc (subseq form 0 n)
			    (cons res (nthcdr (1+ n) form)))))))
      (frob form path context))))


;;;; PREPROCESS-FOR-EVAL and EVAL-IN-FRAME.

;;; PREPROCESS-FOR-EVAL  --  Public.
;;;
;;; Create a SYMBOL-MACRO-LET for each variable valid at the location which
;;; accesses that variable from the frame argument.
;;;
(defun preprocess-for-eval (form loc)
  "Return a function of one argument that will evaluate Form in the lexical
   context of the Basic-Code-Location Loc.  The function take the frame to get
   values from as its argument, and returns the values of Form."
  (declare (type code-location loc))
  (let ((n-frame (gensym))
	(fun (code-location-debug-function loc)))
    (unless (debug-variable-info-available fun)
      (debug-signal 'no-debug-variables :debug-function fun))

    (ext:collect ((binds)
		  (specs))
      (do-debug-function-variables (var fun)
	(let ((validity (debug-variable-validity var loc)))
	  (unless (eq validity :invalid)
	    (let* ((sym (debug-variable-symbol var))
		   (found (assoc sym (binds))))
	      (if found
		  (setf (second found) :ambiguous)
		  (binds (list sym validity var)))))))

      (dolist (bind (binds))
	(let ((name (first bind))
	      (var (third bind)))
	  (ecase (second bind)
	    (:valid
	     (specs `(,name (debug-variable-value ',var ,n-frame))))
	    (:unknown
	     (specs `(,name
		      (debug-signal 'invalid-value
				    :debug-variable ',var
				    :frame ,n-frame))))
	    (:ambiguous
	     (specs `(,name
		      (debug-signal 'ambiguous-variable-name
				    :name ',name
				    :frame ,n-frame)))))))

      (let ((res (coerce `(lambda (,n-frame)
			    (declare (ext:ignorable ,n-frame))
			    (symbol-macro-let ,(specs)
			      ,form))
			 'function)))
	#'(lambda (frame)
	    (unless (code-location= (frame-code-location frame)
				    loc)
	      (debug-signal 'frame-function-mismatch
			    :code-location loc  :form form  :frame frame))
	    (funcall res frame))))))


;;; EVAL-IN-FRAME  --  Public.
;;;
(defun eval-in-frame (frame form)
  (declare (type frame frame))
  "Evaluate Form in the lexical context of Frame's current code location,
   returning the results of the evaluation."
  (funcall (preprocess-for-eval form (frame-code-location frame)) frame))
